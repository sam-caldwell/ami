package main:0.0.1

// A simple worker name G that carries inline GPU kernels for metal/opencl/cuda.
// The build will detect gpuBlocks on G and generate a dynamic workers library
// that can dispatch to available backends. The kernels compute out[i]=i*3.
func G(ev Event<uint64>) (slice<int64>, error) {
  // Metal kernel
  gpu(family="metal", name="mul3_from_i64_slice", n=16, grid=[16,1,1], tpg=[1,1,1]){
    #include <metal_stdlib>
    using namespace metal;
    kernel void mul3_from_i64_slice(device long* out [[buffer(0)]], constant uint& n [[buffer(1)]], uint gid [[thread_position_in_grid]]) {
      if (gid < n) { out[gid] = (long)(gid) * 3; }
    }
  }

  // OpenCL kernel
  gpu(family="opencl", name="mul3_from_i64_slice", n=16, grid=[16,1,1], tpg=[1,1,1], args="1buf1u32"){
    __kernel void mul3_from_i64_slice(__global long* out, unsigned int n) {
      size_t gid = get_global_id(0); if (gid < n) out[gid] = (long)gid * 3;
    }
  }

  // CUDA PTX kernel
  gpu(family="cuda", name="mul3_from_i64_slice", n=16, grid=[16,1,1], tpg=[1,1,1], args="1buf1u32"){
    .version 6.0
    .target sm_30
    .address_size 64
    .visible .entry mul3_from_i64_slice(
      .param .u64 out_ptr,
      .param .u32 n
    ){
      .reg .pred %p;
      .reg .b64 %out, %addr;
      .reg .u32 %tid, %bid, %bdim, %idx, %nval;
      .reg .s64 %val64, %val3;
      ld.param.u64 %out, [out_ptr];
      ld.param.u32 %nval, [n];
      mov.u32 %tid, %tid.x;
      mov.u32 %bid, %ctaid.x;
      mov.u32 %bdim, %ntid.x;
      mad.lo.u32 %idx, %bid, %bdim, %tid;
      setp.ge.u32 %p, %idx, %nval;
      @%p bra DONE;
      cvt.s64.u32 %val64, %idx;
      mul.lo.s64 %val3, %val64, 3;
      mul.wide.u32 %addr, %idx, 8;
      add.s64 %addr, %out, %addr;
      st.global.s64 [%addr], %val3;
    DONE:
      ret;
    }
  }
  // worker returns device-generated values; actual return is provided by the workers lib
  return slice<int64>{}, nil
}

pipeline GpuDemo() {
  Transform(G); egress
}

