// Example AMI program: simple ingress → egress pipeline

package main

// ingressWorker: mock data source (no-op body for demo)
func ingressWorker() {
    // pretend to fetch or produce data
}

// egressWorker: mock sink (no-op body for demo)
func egressWorker() {
    // pretend to write or emit data
}

// stubEventSourceFactory: example factory returning a SourceSpec (shape only).
// Note: parser grammar allows any tokens inside return list; we keep it
// commented to avoid binding to types in this example.
func stubEventSourceFactory() ( /* SourceSpec */ ) {
    // Construct and return a source configuration the compiler would
    // lower into runtime glue (e.g., subscribe to an OS/file/Net source).
    // In real code, this would return something like file.FsNotify(...)
    // or another SourceSpec built from config.
}

// Demo pipeline defined via node-chained notation.
// Per docs (Asynchronous Machine Interface.docx §2.2.4/2.2.5):
// - Pipelines are defined by chaining nodes: Ingress().Transform().Egress()
// - The Ingress "name" attribute identifies the pipeline; there is no
//   `pipeline <identifier> { ... }` block in AMI.
Ingress(
    name=Demo,
    in=stubEventSourceFactory(),
    worker=ingressWorker,
    minWorkers=1,
    maxWorkers=1,
    onError=ErrorPipeline,
    capabilities=[ /* e.g., FileRead:"/opt/input.csv" */ ],
    type=[]byte,
).Egress(
    in=edge.FIFO(
        minCapacity=10,
        maxCapacity=20,
        backpressure=block,
        type=[]byte,
    ),
    worker=egressWorker,
    minWorkers=1,
    maxWorkers=1,
    capabilities=[ /* e.g., NetOut:"db.acme-corp:5432" */ ],
)
