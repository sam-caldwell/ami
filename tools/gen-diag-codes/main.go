package main

import (
    "bufio"
    "fmt"
    "os"
    "path/filepath"
    "regexp"
    "sort"
    "strings"
)

// A lightweight generator that scans Go source for diag.Record literals and extracts
// Code and Data keys to produce docs/diag-codes.md. Not a full Go AST parser; relies
// on simple regex patterns and is best-effort.

var (
    codeRe = regexp.MustCompile(`Code:\s*\"([A-Z]_[A-Z0-9_]+)\"`)
    dataKeyRe = regexp.MustCompile(`Data:\s*map\[string\]any\{([^}]*)\}`)
    kvRe = regexp.MustCompile(`\"([a-zA-Z0-9_]+)\"\s*:`)
)

func main() {
    repoRoot := "."
    codes := map[string]map[string]struct{}{}
    // Scan selected dirs
    roots := []string{"src/ami/compiler/sem", "src/cmd/ami"}
    for _, root := range roots {
        _ = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
            if err != nil || info.IsDir() || !strings.HasSuffix(path, ".go") { return nil }
            f, err := os.Open(path); if err != nil { return nil }
            defer f.Close()
            scanner := bufio.NewScanner(f)
            inRec := false
            braceDepth := 0
            lastCode := ""
            inData := false
            var dataBuf strings.Builder
            for scanner.Scan() {
                line := scanner.Text()
                // track record start/brace depth
                if strings.Contains(line, "diag.Record{") {
                    inRec = true
                    braceDepth = strings.Count(line, "{") - strings.Count(line, "}")
                    lastCode = ""
                } else if inRec {
                    braceDepth += strings.Count(line, "{") - strings.Count(line, "}")
                }
                // code inside record
                if inRec {
                    if cm := codeRe.FindStringSubmatch(line); cm != nil {
                        lastCode = cm[1]
                        if _, ok := codes[lastCode]; !ok { codes[lastCode] = map[string]struct{}{} }
                    }
                    // Data map start
                    if !inData && strings.Contains(line, "Data: map[string]any{") {
                        inData = true
                        dataBuf.Reset()
                        // append after first '{'
                        idx := strings.Index(line, "Data: map[string]any{")
                        if idx >= 0 {
                            rem := line[idx+len("Data: map[string]any{"):]
                            dataBuf.WriteString(rem)
                            // if line already has closing brace, end
                            if strings.Contains(rem, "}") {
                                inData = false
                                content := dataBuf.String()
                                for _, km := range kvRe.FindAllStringSubmatch(content, -1) {
                                    if len(km) > 1 && lastCode != "" { codes[lastCode][km[1]] = struct{}{} }
                                }
                            }
                        }
                        continue
                    }
                    if inData {
                        dataBuf.WriteString(line)
                        if strings.Contains(line, "}") {
                            inData = false
                            content := dataBuf.String()
                            for _, km := range kvRe.FindAllStringSubmatch(content, -1) {
                                if len(km) > 1 && lastCode != "" { codes[lastCode][km[1]] = struct{}{} }
                            }
                        }
                    }
                }
                // end record
                if inRec && braceDepth <= 0 {
                    inRec = false
                    lastCode = ""
                }
            }
            return nil
        })
    }
    // Render
    outPath := filepath.Join(repoRoot, "docs", "diag-codes.md")
    _ = os.MkdirAll(filepath.Dir(outPath), 0o755)
    of, err := os.Create(outPath)
    if err != nil { fmt.Fprintln(os.Stderr, "create diag-codes.md:", err); os.Exit(1) }
    defer of.Close()
    fmt.Fprintln(of, "## Diagnostic Codes and Data Keys (Generated)")
    fmt.Fprintln(of, "")
    fmt.Fprintln(of, "Note: generated by tools/gen-diag-codes; best-effort from code literals.")
    fmt.Fprintln(of, "")
    // Sort codes for determinism
    var codeList []string
    for c := range codes { codeList = append(codeList, c) }
    sort.Strings(codeList)
    for _, c := range codeList {
        fmt.Fprintf(of, "- %s", c)
        keys := make([]string, 0, len(codes[c]))
        for k := range codes[c] { keys = append(keys, k) }
        sort.Strings(keys)
        if len(keys) > 0 { fmt.Fprintf(of, ": data keys = %s", strings.Join(keys, ", ")) }
        fmt.Fprintln(of)
    }
}
