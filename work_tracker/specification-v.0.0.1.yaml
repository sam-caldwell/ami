spec_version: 0.0.1
generated: 2025-09-30T00:00:00Z
authority:
  docx: docs/Asynchronous Machine Interface.docx
notes:
  - AMI language-specific documentation should be kept in docs/language/
  - All work will be performed on the main branch.
  - Any build artifacts, logs or other runtime or test files should be stored in `build/`
  - Changes should be committed to git with each work item performed.
  - Expectations are grouped by `ami` subcommand, then by feature.
  - Where present, `docx` lists relevant sections from the authoritative document.
  - Status mapping: done→complete, todo→ready, partial/checklisted→in progress.
  - Completion means: code complete, ≥0.80 coverage (happy+sad), all tests passing.
  - Codegen order:
      - simplified object format → debug ASM → LLVM objects.
      - binary artifacts should be statically linked
  - Repository conventions:
      - one declaration per file
      - ≥80% coverage per touched package
      - deterministic outputs
      - JSON/human modes
      - errors to stderr
      - JSON lines for streaming
  - directory layout:
      - build directory: `build/`
      - source code: `src/`
      - documentation: `docs/`
      - AMI examples: `examples/`
      - End-to-End tests: `tests/`
  - Event<T>: conceptual generic carrying `value T` and `timestamp time.Time`; used by trigger emissions and similar.
  - io.FHO: |
      file/stream handle abstraction; methods return `(n int, err error)` where applicable; after `.Close()` all 
      operations fail with an error indicating a closed handle.
  - time.Duration: Go-compatible duration; integer nanoseconds with human string forms like `300ms`, `5s`, `2h45m`.
  - io.NetProtocol: enum of network protocols used by socket APIs; values include `TCP`, `UDP`, `ICMP`.

subcommands:
  - id: C-1
    name: root
    features:
      - id: F-1-1
        name: Global Flags & Output Modes
        expectations:
          - id: E-1-1
            statement: As a CLI user, I expect `--help`, `--json`, `--verbose`, and `--color` to be consistently
              available on root and subcommands with enforced incompatibility between `--json` and `--color` and
              correct exit codes.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/root_flags_test.go
              - src/cmd/ami/root_examples_test.go
              - src/cmd/ami/root_more_test.go
              - src/cmd/ami/command_wiring_test.go
              - src/cmd/ami/filter_fields_cli_test.go
              - src/cmd/ami/redact_cli_test.go
              - src/cmd/ami/redact_prefix_cli_test.go
      - id: F-1-2
        name: Structured Logging
        expectations:
          - id: E-1-2
            statement: As an operator, I expect structured logs with human and JSON renderers, redaction controls,
              and verbose logs written to `build/debug` without polluting primary stdout/stderr streams.
            dependencies: []
            status: complete
            tests:
              - src/schemas/log/record_test.go
              - src/cmd/ami/build_compile_logging_test.go
              - src/cmd/ami/build_verbose_kvstore_test.go

  - id: C-2
    name: init
    features:
      - id: F-2-1
        name: Workspace Bootstrapping
        expectations:
          - id: E-2-1
            statement: |
              As a project author, I expect `ami init` to create a default `ami.workspace` with the AMI workspace 
              schema, seed current `os/arch`, and create target and source directories idempotently, with `--force` 
              only adding missing fields.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/init_cmd_test.go
              - src/cmd/ami/cache_dir_test.go
      - id: F-2-2
        name: Git Initialization and Ignoring Build Artifacts
        expectations:
          - id: E-2-2
            statement: |
              As a project author, I expect `ami init` to ensure the repo is initialized with git or to 
              run `git init` when `--force` is provided and create a `.gitignore` that ignores `./build`.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/init_gitignore_test.go

  - id: C-3
    name: clean
    features:
      - id: F-3-1
        name: Build Artifacts Cleanup
        expectations:
          - id: E-3-1
            statement: |
              As a user, I expect `ami clean` to remove and recreate `./build`, emitting human and JSON outputs 
              and correct exit codes on errors.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/clean_cmd_cli_test.go
              - src/cmd/ami/clean_cmd_test.go
              - src/cmd/ami/clean_preserve_sum_test.go

  - id: C-4
    name: mod clean
    features:
      - id: F-4-1
        name: Package Cache Cleanup
        expectations:
          - id: E-4-1
            statement: |
              As a user, I expect `ami mod clean` to remove and recreate the package cache 
              directory `${AMI_PACKAGE_CACHE}` (or default `${HOME}/.ami/pkg`).
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/mod_clean_cmd_test.go
              - src/cmd/ami/mod_clean_run_test.go
              - src/cmd/ami/mod_clean_json_shape_test.go
              - src/cmd/ami/mod_clean_mkdir_fail_test.go

  - id: C-5
    name: mod update
    aliases: [mod sum]
    features:
      - id: F-5-1
        name: Sum Validation and Fetch
        expectations:
          - id: E-5-1
            statement: |
              As a user, I expect `ami mod update` to validate `ami.sum`, verify checksums, resolve version 
              constraints from `ami.workspace`, and download missing packages into the cache, updating `ami.sum` 
              deterministically.
            dependencies: [F-7-1, F-9-1]
            status: complete
            docx: ["2.2.1"]
            tests:
              - src/cmd/ami/mod_sum_cmd_test.go
              - src/cmd/ami/mod_sum_run_test.go
              - src/cmd/ami/mod_sum_json_shape_test.go
              - src/cmd/ami/mod_sum_network_test.go
              - src/cmd/ami/mod_update_cmd_test.go
              - src/cmd/ami/mod_update_run_test.go
              - src/cmd/ami/mod_update_select_test.go
              - src/cmd/ami/mod_update_human_selected_test.go
              - src/cmd/ami/mod_update_json_audit_test.go

      - id: F-5-2
        name: Modules Sum Integrity and Version Checks
        expectations:
          - id: E-5-2
            statement: |
              As a user, I expect `ami mod sum` to validate `ami.sum` format, resolve version constraints consistently
              with `ami.workspace`, and enforce integrity via checksums with clear diagnostics.
            dependencies: [F-7-1]
            status: complete
            docx: ["2.2.1"]
            tests:
              - src/cmd/ami/mod_sum_cmd_test.go
              - src/cmd/ami/mod_sum_run_test.go
              - src/cmd/ami/mod_sum_json_shape_test.go
              - src/cmd/ami/mod_sum_network_test.go

  - id: C-6
    name: mod get
    features:
      - id: F-6-1
        name: Fetch Sources
        expectations:
          - id: E-6-1
            statement: |
              As a user, I expect `ami mod get <url>` to fetch a package via `git+ssh://...#<semver>` or local
              workspace path, place it under `${HOME}/.ami/pkg/<name>/<version>`, and update `ami.sum`.
            dependencies: [F-9-1]
            status: complete
            tests:
              - src/cmd/ami/mod_get_cmd_test.go
              - src/cmd/ami/mod_get_run_test.go
              - src/cmd/ami/mod_get_git_run_test.go
              - src/cmd/ami/mod_get_json_shape_test.go
              - src/cmd/ami/mod_get_network_test.go
              - src/cmd/ami/mod_get_select_semver_test.go
              - src/cmd/ami/mod_get_version_select_test.go

  - id: C-7
    name: mod list
    features:
      - id: F-7-1
        name: List Cached Packages
        expectations:
          - id: E-7-1
            statement: |
              As a user, I expect `ami mod list` to enumerate cached packages with name, version, size, and updated
              timestamp in human and JSON modes.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/mod_list_cmd_test.go
              - src/cmd/ami/mod_list_run_test.go
              - src/cmd/ami/mod_list_human_test.go
              - src/cmd/ami/mod_list_json_shape_test.go
              - src/cmd/ami/mod_list_versions_test.go

  - id: C-8
    name: mod audit
    features:
      - id: F-8-1
        name: Audit Requirements vs Cache
        expectations:
          - id: E-8-1
            statement: |
              As a user, I expect `ami mod audit` to report requirements, missingInSum, unsatisfied constraints,
              missingInCache, mismatched digests, parseErrors, and sumFound with machine-parsable JSON and succinct
              human output.
            dependencies: [F-9-1]
            status: complete
            tests:
              - src/cmd/ami/mod_audit_run_test.go

  - id: C-9
    name: lint
    features:
      - id: F-9-1
        name: Memory Safety Diagnostics
        expectations:
          - id: E-9-1-2.3.2
            statement: |
              As an AMI programmer, I expect the linter to report memory-safety violations including
              `E_PTR_UNSUPPORTED_SYNTAX`, `E_MUT_BLOCK_UNSUPPORTED`, and `E_MUT_ASSIGN_UNMARKED` per AMI 2.3.2.
            dependencies: []
            status: complete
            docx: ["1.9.1", "1.5.4"]
            tests:
              - src/cmd/ami/lint_memsafety_test.go
              - src/cmd/ami/lint_mut_assign_test.go
              - src/cmd/ami/lint_raii_hint_test.go
      - id: F-9-2
        name: Lint Rule Engine and CLI
        expectations:
          - id: E-9-2
            statement: |
              As a user, I expect lint to support naming/import/unused/style rules, strict mode, pragma/config
              suppression, and emit `diag.v1` JSON lines with a final summary.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/lint_cmd_cli_test.go
              - src/cmd/ami/lint_engine_test.go
              - src/cmd/ami/lint_rules_test.go
              - src/cmd/ami/lint_rules_flags_test.go
              - src/cmd/ami/lint_rule_elevation_test.go
              - src/cmd/ami/lint_rule_elevation_human_test.go
              - src/cmd/ami/lint_exit_codes_test.go
      - id: F-9-3
        name: Name Resolution and Types
        expectations:
          - id: E-9-3-2.1
            statement: |
              As a user, I expect deterministic cross-file/package name resolution with stable diagnostics for
              unknown/duplicate symbols per §2.1.*.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/lint_import_recursive_test.go
              - src/cmd/ami/lint_import_cycle_test.go
              - src/cmd/ami/lint_import_cycle_multi_test.go
              - src/cmd/ami/lint_dup_func_test.go
              - src/cmd/ami/lint_import_undeclared_test.go
              - src/cmd/ami/lint_crosspkg_constraints_test.go
              - src/cmd/ami/lint_crosspkg_constraints_conflict_test.go
              - src/cmd/ami/lint_crosspkg_range_test.go
              - src/cmd/ami/lint_crosspkg_single_version_test.go
              - src/cmd/ami/lint_crosspkg_prerelease_test.go
              - src/cmd/ami/lint_pkg_version_test.go

      - id: F-9-4
        name: Merge Attribute Validation
        expectations:
          - id: E-9-4-1.2.4
            statement: |
              As a user, I expect lint to validate merge.* attributes (Buffer/Window/Watermark/Timeout/PartitionBy/
              Dedup/Key/Stable) for arity/type/conflict with deterministic normalization.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/lint_buffer_smells_test.go

      - id: F-9-5
        name: Mutation Enforcement Rules
        expectations:
          - id: E-9-5-2.3.2
            statement: |
              As an AMI programmer, I expect lint to enforce explicit mutation markers and reject unmarked mutations 
              with `E_MUT_ASSIGN_UNMARKED` and related diagnostics.
            dependencies: []
            status: complete

  - id: C-10
    name: test
    features:
      - id: F-10-1
        name: JSON Event Streaming
        expectations:
          - id: E-10-1
            statement: |
              As a user, I expect `ami test` to stream JSON lines for events and a final summary with stable schema,
              honoring CLI flags.
            dependencies: [F-11-1]
            status: complete
            docx: ["1.6"]
            tests:
              - src/cmd/ami/test_json_stream_test.go
              - src/cmd/ami/test_run_test.go
              - src/cmd/ami/test_run_more_test.go
              - src/cmd/ami/test_runtime_cli_test.go
              - src/cmd/ami/test_run_check_events_test.go
              - src/cmd/ami/test_run_human_per_test_lines_test.go
              - src/cmd/ami/test_default_ami_case_test.go
              - src/cmd/ami/test_flags_acceptance_test.go
              - src/cmd/ami/test_cli_conflict_on_subcommand_test.go
      - id: F-10-2
        name: Observability Hooks
        expectations:
          - id: E-10-2-1.6
            statement: |
              As an operator, I expect `diag.v1` emission with event-level IDs/timings, respecting redaction and
              producing deterministic JSON lines per §1.6.*.
            dependencies: [F-11-5]
            status: complete
            tests:
              - src/cmd/ami/events_schema_cmd_test.go
              - src/cmd/ami/events_validate_cmd_test.go
              - src/cmd/ami/errors_schema_cmd_test.go
              - src/cmd/ami/errors_validate_cmd_test.go
              - src/cmd/ami/test_runtime_kv_test.go
              - src/cmd/ami/test_runtime_kv_events_test.go
      - id: F-10-3
        name: Scheduler and Backpressure (Simulated)
        expectations:
          - id: E-10-3-1.4.4
            statement: |
              As a user, I expect deterministic scheduling honoring concurrency/backpressure pragmas with unit tests
              for block/drop policies per §1.4.4–1.4.6.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/lint_buffer_smells_test.go
              - src/cmd/ami/runtime_errorpipeline_test.go
      - id: F-10-4
        name: Runtime Test Harness
        expectations:
          - id: E-10-4
            statement: |
              As a user, I expect `ami test` to execute compiled tests/pipelines and emit JSON lines per event with a
              final summary, integrating AMI directives.
            dependencies: []
            status: complete

  - id: C-11
    name: build
    features:
      - id: F-11-1
        name: End-to-End Build
        expectations:
          - id: E-11-1
            statement: |
              As a user, I expect `ami build` to orchestrate frontend→IR→LLVM→object→link with deterministic artifacts,
              reproducible layouts, and JSON build plans; errors map to standardized exit codes with `diag.v1` streams.
            dependencies:
              - F-11-2
              - F-11-3
            status: complete
            docx: ["1.8.4"]
            tests:
              - src/cmd/ami/build_run_success_test.go
              - src/cmd/ami/build_link_exec_test.go
              - src/cmd/ami/build_link_flags_test.go
              - src/cmd/ami/build_link_darwin_arm64_test.go
              - src/cmd/ami/build_link_darwin_amd64_test.go
              - src/cmd/ami/build_link_linux_arm64_test.go
              - src/cmd/ami/build_link_fail_stderr_test.go
              - src/cmd/ami/build_no_link_env_test.go
              - src/cmd/ami/build_run_objects_nonverbose_test.go
              - src/cmd/ami/build_run_objects_s_test.go
              - src/cmd/ami/build_run_deps_ok_test.go
              - src/cmd/ami/build_run_deps_test.go
              - src/cmd/ami/build_run_json_diag_test.go
              - src/cmd/ami/build_run_json_sem_diags_test.go
              - src/cmd/ami/build_run_schema_error_test.go
              - src/cmd/ami/build_run_missing_root_json_test.go
              - src/cmd/ami/build_run_missing_root_human_test.go
              - src/cmd/ami/build_run_config_test.go
              - src/cmd/ami/build_dir_layout_test.go
              - src/cmd/ami/build_signature_test.go
              - src/cmd/ami/build_multi_package_repeatability_test.go
              - src/cmd/ami/build_run_json_verbose_objindex_test.go
              - src/cmd/ami/build_run_plan_verbose_test.go
              - src/cmd/ami/build_run_plan_json_verbose_test.go
              - src/cmd/ami/build_run_plan_env_objects_test.go
              - src/cmd/ami/build_run_plan_objindex_test.go

      - id: F-11-9
        name: POP Multiple Entrypoints and Error Pipelines
        expectations:
          - id: E-11-9-1.1.5
            statement: |
              As a compiler engineer, I expect multiple Ingress() entrypoints per package with 
              ingress-first/egress-last ordering and error pipeline routing per docx semantics.
            dependencies: [F-11-10, F-9-3]
            status: complete
            docx: ["1.1.5", "1.1.8"]

      - id: F-11-10
        name: IR Core Completeness
        expectations:
          - id: E-11-10-1.9
            statement: |
              As a compiler engineer, I expect IR to cover VAR/ASSIGN/RETURN/DEFER/EXPR, control flow, pipeline edges
              and RAII markers with deterministic JSON under build/debug.
            dependencies: []
            status: complete

      - id: F-11-11
        name: Event Lifecycle Metadata in IR
        expectations:
          - id: E-11-11-1.1.6
            statement: |
              As a runtime integrator, I expect IR to model event metadata (id, timestamp, attempt, trace context) to
              enable observability and diagnostics.
            dependencies: [F-11-10]
            status: complete

      - id: F-11-12
        name: Concurrency Declarations and Scheduling Hints
        expectations:
          - id: E-11-12-1.4
            statement: |
              As a runtime engineer, I expect IR and build artifacts to carry concurrency and scheduling hints honored
              by the runtime scheduler deterministically.
            dependencies: [F-11-10]
            status: complete
            docx: ["1.4.4", "1.4.5", "1.4.6"]

      - id: F-11-13
        name: Backpressure Policies on Edges
        expectations:
          - id: E-11-13-1.2.5
            statement: |
              As a runtime engineer, I expect edge buffer capacities and policies {block, dropOldest, dropNewest} to 
              be encoded and validated with deterministic behavior.
            dependencies: [F-11-10]
            status: complete

      - id: F-11-14
        name: Cross‑package Composition Contracts
        expectations:
          - id: E-11-14-1.3.4
            statement: |
              As a user, I expect type‑safe cross‑package composition with explicit version binding and 
              capability/trust boundaries enforced at build/link time.
            dependencies: [F-9-3]
            status: complete

      - id: F-11-15
        name: Imperative Functions (parameters/results)
        expectations:
          - id: E-11-15-2.2
            statement: |
              As a language user, I expect complete function semantics for parameters and multiple results with return
              checks and deterministic diagnostics.
            dependencies: [F-9-3]
            status: complete

      - id: F-11-16
        name: Imperative Control Flow
        expectations:
          - id: E-11-16-2.3
            statement: |
              As a language user, I expect structured control flow (if/else, loops) lowered to IR branches/loops
              deterministically.
            dependencies: [F-11-17]
            status: complete

      - id: F-11-17
        name: IR Control‑Flow Graph Constructs
        expectations:
          - id: E-11-17-1.10
            statement: |
              As a compiler engineer, I expect structured blocks and phis in IR preserving positions for diagnostics 
              and codegen.
            dependencies: [F-11-10]
            status: complete

      - id: F-11-18
        name: LLVM Emission Hardening
        expectations:
          - id: E-11-18
            statement: |
              As a backend engineer, I expect deterministic LLVM emission for control flow and extended expressions 
              while preserving memory‑safety guarantees.
            dependencies: [F-11-17]
            status: complete
            docx: ["1.8.4"]
            tests:
              - src/ami/compiler/codegen/llvm/cond_phi_test.go
              - src/ami/compiler/codegen/llvm/cmp_float_emit_test.go
              - src/ami/compiler/codegen/llvm/expr_edgecases_test.go
              - src/ami/compiler/codegen/llvm/expr_mod_double_test.go
              - src/ami/compiler/codegen/llvm/defer_lifo_multiblock_test.go
              - src/ami/compiler/codegen/llvm/defer_noexplicit_return_test.go
              - src/ami/compiler/codegen/llvm/extern_order_deterministic_test.go
              - src/ami/compiler/codegen/llvm/abi_backend_safety_test.go

      - id: F-11-19
        name: Runtime ABI Finalization
        expectations:
          - id: E-11-19-1.8.4
            statement: |
              As a runtime engineer, I expect finalized ABI for event/state, Owned<T>, entry and helpers with opaque
              handles and reproducible runtime objects.
            dependencies: [F-11-18]
            status: complete
            tests:
              - src/ami/compiler/codegen/llvm/runtime_zeroize_test.go
              - src/ami/compiler/codegen/llvm/runtime_owned_raii_test.go
              - src/ami/compiler/codegen/llvm/runtime_roundtrip_test.go
              - src/ami/compiler/codegen/llvm/runtime_link_test.go
              - src/ami/compiler/codegen/llvm/runtime_write_nomains_test.go
              - src/ami/compiler/codegen/llvm/entry_write_test.go

      - id: F-11-20
        name: Build E2E Hardening
        expectations:
          - id: E-11-20
            statement: |
              As a user, I expect `ami build` to orchestrate end‑to‑end across environments with stable JSON plans and
              deterministic artifacts beyond current scope.
            dependencies: [F-11-1]
            status: complete
            tests:
              - src/cmd/ami/build_run_plan_json_verbose_test.go
              - src/cmd/ami/build_run_plan_env_objects_test.go
              - src/cmd/ami/build_run_plan_objindex_test.go
              - src/cmd/ami/build_run_plan_deterministic_test.go

      - id: F-11-21
        name: Owned<T> Zeroization and Safety Hooks
        expectations:
          - id: E-11-21
            statement: |
              As a runtime engineer, I expect Owned<T> to zeroize on release/transfer and guard against double release
              with analyzer integration.
            dependencies: []
            status: complete
            docx: ["1.9.1"]

      - id: F-11-22
        name: Observability Hooks (runtime emission)
        expectations:
          - id: E-11-22-1.6
            statement: |
              As an operator, I expect the build/runtime path to support diag/log streams (diag.v1) with redaction
              controls and deterministic JSON lines.
            dependencies: [F-11-11]
            status: complete
            docx: ["1.6"]

      - id: F-11-23
        name: Scheduler and Worker‑pool Execution
        expectations:
          - id: E-11-23-1.4.4
            statement: |
              As a user, I expect a deterministic scheduler honoring concurrency/backpressure pragmas with tests using
              simulated sources.
            dependencies: [F-11-12, F-11-13]
            status: complete

      - id: F-11-24
        name: Edge Buffers with Backpressure
        expectations:
          - id: E-11-24
            statement: |
              As a runtime engineer, I expect bounded queues with {block, dropOldest, dropNewest} policies and
              counters/diagnostics.
            dependencies: [F-11-13]
            status: complete
            docx: ["1.4.4"]

      - id: F-11-25
        name: Merge Engine for Collect
        expectations:
          - id: E-11-25-2.4.0.0
            statement: |
              As a runtime engineer, I expect a merge engine implementing windowing, watermark, timeout, partitioning,
              and stability/tiebreakers enforcing orderability.
            dependencies: [F-11-4]
            status: complete

      - id: F-11-26
        name: Backend Safety Assertions
        expectations:
          - id: E-11-26
            statement: |
              As a user, I expect no public ABI exposes raw pointers; failing cases produce E_LLVM_EMIT diagnostics.
            dependencies: [F-11-18]
            status: complete
            docx: ["1.9.1"]

      - id: F-11-27
        name: Branching/Loop Lowering (Codegen)
        expectations:
          - id: E-11-27
            statement: |
              As a backend engineer, I expect IR CFG constructs lowered to LLVM with stable block ordering and phis.
            dependencies: [F-11-17]
            status: complete

      - id: F-11-28
        name: Stream Tool Diagnostics
        expectations:
          - id: E-11-28
            statement: |
              As a user, I expect compiler/tool/clang failures to stream as diag.v1 records with consistent exit‑code
              mapping.
            dependencies: [F-11-22]
            status: complete
            docx: ["1.6"]

      - id: F-11-29
        name: Security and Trust Boundaries
        expectations:
          - id: E-11-29-1.3.4
            statement: |
              As a user, I expect explicit capability/trust boundary declarations enforced at compile/link with
              diagnostics; no implicit propagation.
            dependencies: [F-11-14]
            status: complete
            docx: ["1.3.4"]

      - id: F-11-30
        name: Source Isolation and Sandboxing Hooks
        expectations:
          - id: E-11-30-1.2.3
            statement: |
              As a runtime integrator, I expect hooks for ingress/source sandboxing per policy (fs/net/device
              capabilities) with deterministic tests via simulated sources.
            dependencies: [F-11-23]
            status: complete
            docx: ["1.2.3"]

      - id: F-11-31
        name: Sensitive‑data Zeroization Policy
        expectations:
          - id: E-11-31
            statement: |
              As a security engineer, I expect a policy and implementation for zeroization across Owned<T>, buffers, 
              and node‑state with redacted observability.
            dependencies: [F-11-21]
            status: complete
            docx: ["1.9.1"]
            tests:
              - src/ami/compiler/codegen/llvm/runtime_zeroize_test.go
              - src/ami/compiler/codegen/llvm/runtime_owned_raii_test.go
              - src/ami/runtime/merge/zeroize_policy_test.go

      - id: F-11-32
        name: Minimal Examples and Docs Updates
        expectations:
          - id: E-11-32
            statement: |
              As a user, I expect a minimal end‑to‑end POP example to build/run across supported targets with docs
              updated.
            dependencies: [F-11-1]
            status: complete
            tests:
              - src/cmd/ami/examples_minimal_build_test.go

      - id: F-11-33
        name: Generic Constraints and Unification
        expectations:
          - id: E-11-33-2.1
            statement: |
              As a language user, I expect generic constraints (e.g., any) and conservative unification across 
              calls/returns with stable diagnostics (E_TYPE_UNINFERRED/E_TYPE_AMBIGUOUS) per §2.1.*.
            dependencies: [F-11-15]
            status: complete
            tests:
              - src/ami/compiler/sem/calls_generics_unify_test.go
              - src/ami/compiler/sem/calls_generics_unify_local_test.go
              - src/ami/compiler/sem/calls_generics_constraints_any_test.go
              - src/ami/compiler/sem/ambiguous_test.go
              - src/ami/compiler/sem/return_infer_test.go

      - id: F-11-34
        name: Type Inference M2/M3
        expectations:
          - id: E-11-34-2.1
            statement: |
              As a language user, I expect container element/key inference, tuple returns, and propagation through 
              Event<T>/Error<E> with conservative generic compatibility and stable positions in diagnostics per §2.1.*.
            dependencies: [F-11-15]
            status: complete
            tests:
              - src/ami/compiler/sem/inference_propagation_test.go
              - src/ami/compiler/sem/return_types_test.go
              - src/ami/compiler/sem/return_infer_containers_test.go
              - src/ami/compiler/sem/return_types_with_sigs.go
              - src/ami/compiler/sem/return_infer_generic_event_error_test.go
      - id: F-11-2
        name: Debug Artifacts (verbose)
        expectations:
          - id: E-11-2
            statement: |
              As a developer, I expect `--verbose` to emit resolved sources, AST/IR JSON, assembly, edges summaries, 
              activity logs, and manifest cross-references under `build/debug` only when verbose.
            dependencies: [F-11-3]
            status: complete
            tests:
              - src/cmd/ami/build_verbose_manifest_refs_test.go
              - src/cmd/ami/build_verbose_kvstore_test.go
              - src/cmd/ami/build_run_verbose_ast_test.go
              - src/cmd/ami/build_run_verbose_asm_test.go
              - src/cmd/ami/build_run_no_verbose_nodebug_test.go
      - id: F-11-3
        name: Workspace/Manifest Validation
        expectations:
          - id: E-11-3
            statement: |
              As a user, I expect workspace schema validation and integrity checks between `ami.manifest`, `ami.sum`, 
              and the cache with clear `E_WS_SCHEMA` and `E_INTEGRITY*` diagnostics.
            dependencies: [F-5-1]
            status: complete
            tests:
              - src/cmd/ami/build_manifest_integrity_test.go
              - src/cmd/ami/build_manifest_artifacts_test.go
              - src/cmd/ami/build_write_manifest_test.go
              - src/cmd/ami/build_write_manifest_env_objects_test.go
              - src/cmd/ami/build_write_manifest_env_objects_darwin_arm64_test.go
              - src/cmd/ami/build_integrity_diag_test.go
      - id: F-11-4
        name: Merge/Collect IR Extensions
        expectations:
          - id: E-11-4-2.4.0.0
            statement: |
              As a compiler engineer, I expect IR to encode sort keys, windows, watermarks, partitions, and 
              backpressure attributes for Collect nodes per §2.4.0.0.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/lint_merge_sort_test.go
      - id: F-11-5
        name: Runtime ABI Finalization
        expectations:
          - id: E-11-5-1.8.4
            statement: |
              As a runtime engineer, I expect finalized ABI for event/state, Owned<T>, and helpers with opaque handles
              and reproducible runtime objects per §1.8.4.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/runtime_parse_test.go
              - src/ami/compiler/codegen/llvm/runtime_zeroize_test.go
              - src/ami/compiler/codegen/llvm/runtime_owned_raii_test.go
              - src/ami/compiler/codegen/llvm/runtime_roundtrip_test.go
              - src/ami/compiler/codegen/llvm/runtime_link_test.go
      - id: F-11-6
        name: Target linux/arm64
        expectations:
          - id: E-11-6
            statement: |
              As a user, I expect linux/arm64 builds to compile and link with deterministic artifacts when toolchains 
              are available, and that all artifacts will be statically linked.
            dependencies: [F-11-5]
            status: complete
            tests:
              - src/cmd/ami/build_link_linux_arm64_test.go
      - id: F-11-7
        name: Target darwin/amd64
        expectations:
          - id: E-11-7
            statement: |
              As a user, I expect darwin/amd64 builds to compile and link with deterministic artifacts when 
              toolchains are available, and that all artifacts will be statically linked.
            dependencies: [F-11-5]
            status: complete
            tests:
              - src/cmd/ami/build_link_darwin_amd64_test.go
      - id: F-11-8
        name: Target linux/amd64
        expectations:
          - id: E-11-8
            statement: |
              As a user, I expect linux/amd64 builds to compile and link with deterministic artifacts when toolchains 
              are available, and that all artifacts will be statically linked.
            dependencies: [F-11-5]
            status: complete
            tests:
              - src/cmd/ami/build_link_exec_test.go
          - id: E-11-9
            statement: |
              As a user, I expect I can build an executable linux/amd64 binary test POP/AMI program and run it 
              successfully in a docker container in order to validate compiler/linker operation, and I expect that
              the binary will run with no external dependencies beyond the operating system.
            dependencies: [F-11-5]
            status: complete
            tests:
              - src/cmd/ami/build_link_exec_test.go

  - id: C-12
    name: pipeline visualize
    features:
      - id: F-12-1
        name: ASCII and JSON Graphs
        expectations:
          - id: E-12-1
            statement: |
              As a user, I expect `ami pipeline visualize` to render deterministic ASCII graphs in human mode 
              and `graph.v1` JSON in machine mode, detecting cycles as `E_GRAPH_CYCLE` and exiting non-zero.
            dependencies: []
            status: complete
            docx: ["1.8.2"]
            tests:
              - src/cmd/ami/pipeline_cmd_test.go
              - src/cmd/ami/pipeline_visualize_ascii_test.go
              - src/cmd/ami/pipeline_visualize_json_test.go
              - src/cmd/ami/pipeline_visualize_cycle_json_test.go
              - src/cmd/ami/pipeline_visualize_json_exclude_test.go
              - src/cmd/ami/pipeline_visualize_json_nosummary_test.go
              - src/cmd/ami/pipeline_visualize_filter_test.go

  - id: C-13
    name: version
    features:
      - id: F-13-1
        name: Version Reporting
        expectations:
          - id: E-13-1
            statement: |
              As a user, I expect `ami version` to report the build-time injected version (ldflags) consistently.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/version_cmd_test.go
              - src/cmd/ami/version_cmd_json_test.go

  - id: C-14
    name: help
    features:
      - id: F-14-1
        name: Embedded Help Content
        expectations:
          - id: E-14-1
            statement: |
              As a user, I expect `ami help` to display embedded content sourced from `docs/toolchain/help-guide/**/*.md` via 
              `go:embed` with consistent formatting and paging behavior.
            dependencies: []
            status: complete
            tests:
              - src/cmd/ami/help_cmd_test.go
              - src/cmd/ami/help_content_test.go
              - src/cmd/ami/examples_help_test.go
              - src/cmd/ami/help_examples_test.go

      - id: F-14-2
        name: Gaps Reconciliation
        expectations:
          - id: E-14-2
            statement: |
              As a maintainer, I expect the YAML and docx gaps to be captured and reconciled, with missing features 
              listed explicitly in this YAML and tracked to closure.
            dependencies: []
            status: complete
            tests:
              - docs/gaps.md

cross_cutting:
  gates:
    - id: CC-1
      statement: |
        All features must maintain ≥0.80 coverage on changed packages with happy and sad path tests; `go vet`, 
        `go test`, and build must be green.
      status: complete
  risks:
    - id: CC-2
      statement: |
        No public ABI may expose raw pointers; enforce via codegen safety assertions and tests.
      status: complete
    - id: CC-3
      statement: |
        All memory must be allocated and managed in an RAII compliant manner.
      status: complete

stdlib:
  - id: S-1
    name: io package
    features:
      - id: F-1-1
        name: Stdlib File Input / Output
        expectations:
          - id: E-1-1-1
            statement: |
              As a user, I expect the stdlib to have a built-in `io` package for file input and output.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go
              - src/ami/runtime/host/io/more_coverage_test.go

          - id: E-1-1-2
            statement: |
              As a user, I expect that AMI `io` package will have a file handle object (FHO) representing a file and 
              its underlying file handle.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go

          - id: E-1-1-3
            statement: |
              As a user, I expect the AMI `io` package to have an `io.OpenFile(...)` function comparable to Go's
              `os.Open(...)`, except that it returns an `io.FHO` and error object rather than a file handle pointer.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go

          - id: E-1-1-4
            statement: |
              As a user, I expect that AMI `io.FHO` type will manage all file I/O for its given file; the io.FHO 
              will have a .Close() method to close the file/handle, after which it should be freed in memory and 
              unusable; the io.FHO object should have .Read(), .ReadBytes(), .Write(), .WriteBytes(), .Seek() and 
              other such functions as needed to perform file I/O.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go

          - id: E-1-1-5
            statement: |
              As a user, I expect `io.FHO` operations to be safe and deterministic: after .Close(), any subsequent
              .Read(), .ReadBytes(), .Write(), .WriteBytes(), .Seek(), .Flush(), or .Truncate() call must fail with an
              error indicating the handle is closed; .Read()/.Write() return the number of bytes processed and a 
              non-nil error on partial operations; and .Seek(offset, whence) follows standard POSIX whence semantics.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go
              - src/ami/runtime/host/io/more_coverage_test.go

          - id: E-1-1-6
            statement: |
              As a user, I expect the AMI `io.FHO` type will have a .Length() method which will return the file size,
              a .Pos() method which returns the current file position for read/write operations, a .Truncate() method
              used to truncate the file.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go
              - src/ami/runtime/host/io/more_coverage_test.go

          - id: E-1-1-7
            statement: |
              As a user, I expect the AMI `io.FHO` type will have a .Flush() method to flush file buffers to disk.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go

          - id: E-1-1-8
            statement: |
              As a user, I expect the AMI `io` package will have a `CreateTemp([dir string][,suffix string])` function 
              to create a temporary file and return the `io.FHO` object used to manage the file content; and the `dir`
              directory string will be relative to the system temporary directory.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go

          - id: E-1-1-9
            statement: |
              As a user, I expect the AMI `io` package will have a `CreateTempDir()` function to create a temporary
              directory and return the directory path (string); and the temporary directory will be created relative to
              the system temporary directory.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go

          - id: E-1-1-10
            statement: |
              As a user, I expect the AMI `io` package will have a Stat(fileName string) function which will return
              a struct containing the file information about the given fileName.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go

      - id: F-1-2
        name: Stdlib Console Input / Output
        expectations:
          - id: E-1-2-1
            statement: |
              As a user, I expect the AMI `io` package will have a special FHO called io.Stdin for reading from stdin;
              and this FHO will behave like any other FHO with all the same methods and properties.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go
              - src/ami/runtime/host/io/more_coverage_test.go

          - id: E-1-2-2
            statement: |
              As a user, I expect the AMI `io` package will have a special FHO called io.Stdout for writing to
              stdout; and this FHO will behave like any other FHO with all the same methods and properties.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go

          - id: E-1-2-3
            statement: |
              As a user, I expect the AMI `io` package will have a special FHO called io.Stderr for writing to
              stderr; and this FHO will behave like any other FHO with all the same methods and properties.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_test.go

      - id: F-1-3
        name: Stdlib Network Input / Output
        expectations:
          - id: E-1-3-1
            statement: |
              As a user, I expect the AMI `io` package will provide a network `io.Socket` handle type that is
              equivalent to an `io.FHO`, representing a socket opened for input/output with the same methods and
              properties as a file `io.FHO` where applicable.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/socket_udp_test.go
              - src/ami/runtime/host/io/socket_tcp_test.go
              - src/ami/runtime/host/io/socket_read_test.go
              - src/ami/runtime/host/io/socket_tcp_listen_test.go
              - src/ami/runtime/host/io/more_coverage_test.go

          - id: E-1-3-2
            statement: |
              As a user, I expect the AMI `io` package will have an `io.OpenSocket(proto io.NetProtocol, addr string,
              port uint16)` function to open a network socket handle (FHO-equivalent) for a given protocol (e.g., ICMP,
              UDP, TCP), host IP,
              and port.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/socket_udp_test.go
              - src/ami/runtime/host/io/socket_tcp_test.go
              - src/ami/runtime/host/io/socket_tcp_listen_test.go

          - id: E-1-3-3
            statement: |
              As a user, I expect the AMI `io.Socket` handle to support .Close() to close the socket; .Write() to
              write messages to the socket buffer; .Send() to send buffered contents; and .Listen() to register a
              handler invoked for incoming network traffic, mirroring `io.FHO` semantics where applicable.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/socket_udp_test.go
              - src/ami/runtime/host/io/socket_tcp_test.go
              - src/ami/runtime/host/io/socket_helpers_test.go

          - id: E-1-3-4
            statement: |
              As a user, I expect the AMI `io` package will have an `io.Hostname()` method which will return the 
              current hostname of the underlying system.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_network_test.go

          - id: E-1-3-5
            statement: |
              As a user, I expect the AMI `io` package will have an `io.Interfaces()` method which will list all
              network interfaces.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/io/file_network_test.go

      - id: F-1-4
        name: I/O POP Capability Enforcement
        expectations:
          - id: E-1-4-1
            statement: |
              As a user, I expect the AMI `io` package will enforce all I/O capabilities, as defined for
              the pipeline and the POP paradigm generally; only Ingress or egress nodes can use the io package,
              and only ingress and egress nodes can use the I/O features specifically allowed in their capabilities
              attributes.
            dependencies: [F-11-23]
            status: complete
            tests:
              # Driver/IR-level capability + position enforcement
              - src/ami/compiler/driver/capabilities_test.go
              - src/ami/compiler/driver/capabilities_driver_test.go
              # CLI JSON diagnostic streaming parity (build path)
              - src/cmd/ami/build_capability_trust_diag_test.go

  - id: S-2
    name: os package exec()
    features:
      - id: F-2-1
        name: Stdlib Operating System Interface (Process Runner)
        expectations:
          - id: E-2-1-1
            statement: |
              As a user, I expect the stdlib to have a built-in `os` package for interacting with the operating system.
            dependencies: []
            status: complete
            tests: []

          - id: E-2-1-2
            statement: |
              As a user, I expect the AMI `os` package will have a `Process` object type used to represent a process
              spawned by the program; the os.Process type will be used to manage the process lifecycle.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/os/process_test.go
              - src/ami/runtime/host/os/process_io_kill_test.go
              - src/ami/runtime/host/os/process_helpers_test.go
              - src/ami/runtime/host/os/process_kill_unix_test.go

          - id: E-2-1-3
            statement: |
              As a user, I expect the AMI `os` package will have an `Exec()` which will initialize a given external 
              program and return a os.Process object and error object; the os.Process object will be used to manage
              the process lifecycle; and the Exec() function will initialize but NOT start the new process.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/os/process_test.go
              - src/ami/runtime/host/os/process_helpers_test.go

          - id: E-2-1-4
            statement: |
              As a user, I expect the AMI `os.Process` object type will have a .Kill() method to immediately terminate
              the process, a .Status() method to return process state information (as a struct), a .Stdin() method for
              interacting over stdin, a .Stdout() and .Stderr() method for obtaining process outputs on stdout and
              stderr, a .Pid() method for obtaining the process id, and a .Start() method to launch the process.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/os/process_test.go
              - src/ami/runtime/host/os/process_io_kill_test.go
              - src/ami/runtime/host/os/process_helpers_test.go

          - id: E-2-1-5
            statement: |
              As a user, I expect the AMI `os.Process` .Start() method will accept an optional boolean value to 
              indicate whether it blocks or runs the executed process asynchronously.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/os/process_test.go
              - src/ami/runtime/host/os/process_helpers_test.go

          - id: E-2-1-6
            statement: |
              As a user, I expect that AMI `os` package will have an `os.SystemStats()` method return a struct
              describing the system's hardware.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/os/system_test.go
              - src/ami/runtime/host/os/watch_test.go

  - id: S-3
    name: os package (general)
    features:
      - id: F-3-1
        name: environment variable
        expectations:
          - id: E-3-1-1
            statement: |
              As a user, I expect the AMI os package to have a .GetEnv() method which will return the value of an
              environment variable given the environment variable name.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/os/env_test.go
              - src/ami/runtime/host/os/process_helpers_test.go

          - id: E-3-1-2
            statement: |
              As a user, I expect the AMI os package to have a .SetEnv() method which will set the value of an
              environment variable given the environment variable name.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/os/env_test.go
              - src/ami/runtime/host/os/process_helpers_test.go

          - id: E-3-1-3
            statement: |
              As a user, I expect the AMI os package to have a .ListEnv() method which will return a list of 
              environment variable names (not their values).
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/os/env_test.go
              - src/ami/runtime/host/os/process_helpers_test.go

  - id: S-4
    name: signal package (AMI stdlib)
    features:
      - id: F-4-1
        name: signal handler
        expectations:
          - id: E-4-1-1
            statement: |
              As a user, I expect there to be an AMI 'signal' package which will provide signal handling facilities.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/signal/signal_test.go
              - src/ami/runtime/host/signal/more_signal_test.go
              - src/ami/compiler/driver/signal_enable_llvm_test.go

          - id: E-4-1-2
            statement: |
              As a user, I expect there to be a built-in `SignalType` enum data type representing each operating 
              system signal (e.g., SIGINT, SIGTERM, etc.).
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/signal/signal_test.go
              - src/ami/runtime/host/signal/more_signal_test.go
              - src/ami/compiler/driver/signal_mapping_more_llvm_test.go

          - id: E-4-1-3
            statement: |
              As a user, I expect there to be a `signal.Register(sig SignalType, fn func())` function which will 
              register a signal handler function for a given os signal.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/signal/signal_test.go
              - src/ami/runtime/host/signal/more_signal_test.go
              - src/ami/compiler/driver/signal_register_llvm_test.go
              - src/ami/compiler/driver/signal_register_immediate_llvm_test.go
              - src/ami/compiler/driver/signal_register_selector_llvm_test.go
              - src/ami/compiler/driver/signal_register_fallback_llvm_test.go

  - id: S-5
    name: time package (AMI stdlib)
    features:
      - id: F-5-1
        name: time handler
        expectations:
          - id: E-5-1-1
            statement: |
              As a user, I expect there to be an AMI 'time' package which will provide time clock facilities
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/time_test.go

          - id: E-5-1-2
            statement: |
              As a user, I expect there to be a `time.Sleep(d time.Duration)` function which will cause the program to
              sleep for duration d; `time.Duration` follows Go's pattern and units (ns, us, ms, s, m, h).
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/time_test.go

          - id: E-5-1-3
            statement: |
              As a user, I expect there to be a `time.Time` object representing a time/date value.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/time_test.go

          - id: E-5-1-4
            statement: |
              As a user, I expect there to be a `time.Now()` function which will return the current `time.Time` object
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/time_test.go

          - id: E-5-1-5
            statement: |
              As a user, I expect there to be a `time.Delta(t1, t2 time.Time)` function which will return the time
              difference between t1 and t2.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/time_test.go

          - id: E-5-1-6
            statement: |
              As a user, I expect there to be a `time.Add(t time.Time, d time.Duration)` function which will return
              the time t advanced by duration d.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/time_test.go

          - id: E-5-1-7
            statement: |
              As a user, I expect the `time.Time` object to have a .Unix() method which returns a unix timestamp in
              seconds.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/time_test.go

          - id: E-5-1-8
            statement: |
              As a user, I expect the `time.Time` object to have a .UnixNano() method which returns a unix timestamp in
              nanoseconds.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/time_test.go

      - id: F-5-2
        name: time handler
        expectations:
          - id: E-5-2-1
            statement: |
              As a user, I expect the `time` package will have a `Ticker` object returned by 
              `NewTicker(d time.Duration)`; d uses `time.Duration` with Go-style units; the object executes a 
              registered function for every clock tick event.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/ticker_test.go
              - src/ami/runtime/host/time/ticker_more_test.go

          - id: E-5-2-2
            statement: |
              As a user, I expect the `time.Ticker` object will have a `.Start()` method to start the ticker generating
              tick events.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/ticker_test.go
              - src/ami/runtime/host/time/ticker_more_test.go

          - id: E-5-2-3
            statement: |
              As a user, I expect the `time.Ticker` object will have a `.Stop()` method to stop the ticker from 
              generating tick events.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/ticker_test.go
              - src/ami/runtime/host/time/ticker_more_test.go

          - id: E-5-2-4
            statement: |
              As a user, I expect the `time.Ticker` object will have a `.Register(f func())` method to execute for 
              each timer tick event.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/time/ticker_test.go
              - src/ami/runtime/host/time/ticker_more_test.go

  - id: S-6
    name: trigger package
    features:
      - id: F-6-1
        name: trigger facility for ingress nodes.
        expectations:
          - id: E-6-1-1
            statement: |
              As a user, I expect AMI to have a built-in `trigger` package which will provide trigger event facilities
              for Ingress node `in` attribute.
            dependencies: [F-11-11, F-11-23]
            status: complete
            tests:
              - src/ami/runtime/host/trigger/timer_schedule_test.go
              - src/ami/runtime/host/trigger/fsnotify_test.go
              - src/ami/runtime/host/trigger/fsnotify_interval_env_test.go
              - src/ami/runtime/host/trigger/netlisten_tcp_test.go
              - src/ami/runtime/host/trigger/netlisten_udp_test.go

      - id: F-6-2
        name: trigger facility for Time-based events
        expectations:
          - id: E-6-2-1
            statement: |
              As a user, I expect AMI to have a `trigger.Timer(d time.Duration)` method which will emit an
              Event<time.Time> object every d units of time; `time.Duration` follows Go's pattern and units.
            dependencies: [F-11-23]
            status: complete
            tests:
              - src/ami/runtime/host/trigger/timer_schedule_test.go

          - id: E-6-2-2
            statement: |
              As a user, I expect AMI to have a `trigger.Schedule(t time.Time)` method which will emit an 
              Event<time.Time> object at t time.
            dependencies: [F-11-23]
            status: complete
            tests:
              - src/ami/runtime/host/trigger/timer_schedule_test.go

      - id: F-6-3
        name: trigger facility for Filesystem Events
        expectations:
          - id: E-6-3-1
            statement: |
              As a user, I expect AMI to have a `trigger.FsEvent` enum representing a generic set of inotify events
              common to linux, windows and MacOS platforms.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/trigger/fs.go
              - src/ami/runtime/host/trigger/fsnotify_test.go

          - id: E-6-3-2
            statement: |
              As a user, I expect AMI to have a `trigger.FileEvent` object containing a file handle object (FHO),
              the `trigger.FsEvent` and event timestamp.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/trigger/fs.go
              - src/ami/runtime/host/trigger/fsnotify_test.go

          - id: E-6-3-4
            statement: |
              As a user, I expect AMI to have a `trigger.FsNotify(path string, t trigger.FsEvent)` method which will 
              emit an `Event<trigger.FileEvent>` object when a file system operation of type `trigger.FsEvent` occurs 
              on the given `path`,
            dependencies: [F-11-23]
            status: complete
            tests:
              - src/ami/runtime/host/trigger/fsnotify_test.go
              - src/ami/runtime/host/trigger/fsnotify_interval_env_test.go

      - id: F-6-4
        name: trigger facility for Network Events
        expectations:
          - id: E-6-4-1
            statement: |
              As a user, I expect AMI to have a `trigger.NetListen(proto io.NetProtocol, addr string, port uint16)`
              method which will emit an `Event<trigger.NetMsg>` object when a network message is received; where
              `trigger.NetMsg` will contain the contents of a network message and timestamp.
            dependencies: [F-11-23]
            status: complete
            tests:
              - src/ami/runtime/host/trigger/netlisten_tcp_test.go
              - src/ami/runtime/host/trigger/netlisten_udp_test.go

          - id: E-6-4-2
            statement: |
              As a user, I expect AMI to define a `trigger.NetMsg` object containing the message payload, protocol,
              remote and local addresses/ports, and an event timestamp.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/trigger/net.go

          - id: E-6-4-3
            statement: |
              As a user, I expect `trigger.NetListen(...)` emissions to include enough metadata for handlers to route
              by protocol or address and to be compatible with backpressure policies in the runtime event pipeline.
            dependencies: [F-11-23, F-11-24]
            status: complete
            tests:
              - src/ami/runtime/host/trigger/netlisten_tcp_test.go
              - src/ami/runtime/host/trigger/netlisten_udp_test.go

  - id: S-7
    name: math package
    features:
      - id: F-7-1
        name: Core Float Math
        expectations:
          - id: E-7-1-1
            statement: |
              As a user, I expect a stdlib `math` package modeled on Go's math as a baseline, operating on `float64`
              with deterministic behavior across platforms and consistent with the AMI authoritative semantics.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/runtime/host/math/more_math_test.go
              - src/ami/compiler/driver/stdlib_math_remaining_ami_test.go

          - id: E-7-1-2
            statement: |
              As a user, I expect `math.Abs(x float64) float64`, `math.Max(x, y float64) float64`, and
              `math.Min(x, y float64) float64` to behave like Go, including NaN propagation rules.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/compiler/driver/stdlib_math_remaining_ami_test.go

          - id: E-7-1-3
            statement: |
              As a user, I expect rounding helpers `math.Ceil(x)`, `math.Floor(x)`, `math.Trunc(x)`, and
              `math.Round(x)`, `math.RoundToEven(x)` to be available with Go-aligned semantics.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/runtime/host/math/more_math_test.go
              - src/ami/compiler/driver/stdlib_math_remaining_ami_test.go

          - id: E-7-1-4
            statement: |
              As a user, I expect `math.Mod(x, y float64) float64` to match Go semantics (sign of result follows x),
              and `math.Remainder(x, y float64) float64` to implement IEEE 754 remainder.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/compiler/driver/stdlib_math_more_ami_test.go

      - id: F-7-2
        name: Exp, Log, Pow, Sqrt
        expectations:
          - id: E-7-2-1
            statement: |
              As a user, I expect exponentials `math.Exp(x)`, `math.Expm1(x)`, and `math.Exp2(x)` to be provided with
              Go-compatible edge-case handling (Inf, NaN).
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/compiler/driver/stdlib_math_remaining_ami_test.go

          - id: E-7-2-2
            statement: |
              As a user, I expect logarithms `math.Log(x)`, `math.Log10(x)`, `math.Log1p(x)`, and `math.Log2(x)` with
              Go-compatible domains and NaN/Inf behavior.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/compiler/driver/stdlib_math_remaining_ami_test.go

          - id: E-7-2-3
            statement: |
              As a user, I expect `math.Pow(x, y) float64`, `math.Pow10(n int) float64`, and `math.Sqrt(x) float64`
              with the same corner-case handling as Go (including negative, zero, Inf, and NaN inputs).
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/compiler/driver/stdlib_math_remaining_ami_test.go

      - id: F-7-3
        name: Trigonometric and Hyperbolic
        expectations:
          - id: E-7-3-1
            statement: |
              As a user, I expect trigonometric functions `math.Sin`, `math.Cos`, `math.Tan`, and combined 
              `math.Sincos` with Go-compatible precision and special case behavior.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/compiler/driver/stdlib_math_remaining_ami_test.go

          - id: E-7-3-2
            statement: |
              As a user, I expect inverse trig functions `math.Asin`, `math.Acos`, `math.Atan`, and `math.Atan2` with
              Go-aligned range and domain semantics.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/runtime/host/math/more_math_test.go
              - src/ami/compiler/driver/stdlib_math_remaining_ami_test.go

          - id: E-7-3-3
            statement: |
              As a user, I expect hyperbolic functions `math.Sinh`, `math.Cosh`, and `math.Tanh` with Go-compatible
              edge-case handling.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/compiler/driver/stdlib_math_even_more_ami_test.go

      - id: F-7-4
        name: Special Values and Classification
        expectations:
          - id: E-7-4-1
            statement: |
              As a user, I expect `math.NaN() float64` and `math.Inf(sign int) float64` to construct special values,
              and that operations propagate NaN/Inf consistent with IEEE‑754 and Go's behavior.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/compiler/driver/stdlib_math_remaining_ami_test.go

          - id: E-7-4-2
            statement: |
              As a user, I expect classification and manipulation helpers: `math.IsNaN(x)`, `math.IsInf(x, sign)`,
              `math.Signbit(x)`, `math.Copysign(x, y)`, and `math.Nextafter(x, y)`.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/runtime/host/math/more_math_test.go
              - src/ami/compiler/driver/stdlib_math_even_more_ami_test.go

          - id: E-7-4-3
            statement: |
              As a user, I expect decomposition helpers `math.Frexp(x) (frac float64, exp int)`,
              `math.Ldexp(frac float64, exp int) float64`, and `math.Modf(x) (intPart, fracPart float64)`.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/runtime/host/math/more_math_test.go
              - src/ami/compiler/driver/stdlib_math_more_ami_test.go

      - id: F-7-5
        name: Mathematical Constants
        expectations:
          - id: E-7-5-1
            statement: |
              As a user, I expect common constants aligned with Go: `math.Pi`, `math.E`, `math.Phi`, `math.Sqrt2`,
              `math.Ln2`, `math.Ln10`, `math.Log2E`, and `math.Log10E`.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/math/math_test.go
              - src/ami/compiler/driver/stdlib_math_ami_test.go

      - id: F-8
        name: Multi-Result IR/LLVM and Full math Lowering
        expectations:
          - id: E-8-1
            statement: |
              As a compiler engineer, I expect the IR to represent multi-result expressions and calls by extending
              `ir.Expr` with `Results []ir.Value` (retaining `Result *ir.Value` for single returns) and updating
              IR JSON encoding to include multi-result signatures for calls.
            dependencies: []
            status: complete
            tests:
              - src/ami/compiler/ir/encode_expr_call_test.go

          - id: E-8-2
            statement: |
              As a compiler engineer, I expect lowering to produce `Expr.Results` for multi-result calls using
              known function signatures, and for `return` lowering to collect/expand multi-result expressions so that
              `ir.Return{Values: ...}` receives the correct arity and types.
            dependencies: [F-8-1]
            status: complete
            tests:
              - src/ami/compiler/driver/return_tuple_aggregate_summary_test.go
              - src/ami/compiler/driver/return_tuple_mixed_summary_paths_test.go

          - id: E-8-3
            statement: |
              As a backend engineer, I expect the LLVM emitter to support multi-result functions by emitting
              aggregate return types `{T0,T1,...}`, constructing returns via `insertvalue`, and consuming call results
              via `extractvalue`. Calls with multiple results emit `call {…}` then `extractvalue` into SSA temps.
              User function ABIs must not expose raw pointers; pointer-like types map to safe integer or opaque
              handles as appropriate.
            dependencies: [F-8-1]
            status: complete
            tests:
              - src/ami/compiler/codegen/llvm/module_test.go
              - src/ami/compiler/codegen/llvm/cond_phi_test.go

          - id: E-8-4
            statement: |
              As a language implementer, I expect stdlib `math` lowering to be end-to-end without stubs:
              single-result functions map to LLVM intrinsics (e.g., `llvm.fabs.f64`, `llvm.minnum.f64`, `llvm.maxnum.f64`,
              `llvm.ceil.f64`, `llvm.floor.f64`, `llvm.trunc.f64`, `llvm.exp.f64`, `llvm.exp2.f64`, `llvm.log.f64`,
              `llvm.log2.f64`, `llvm.log10.f64`, `llvm.sqrt.f64`, `llvm.pow.f64`, `llvm.sin.f64`, `llvm.cos.f64`,
              `llvm.tan.f64`, `llvm.sinh.f64`, `llvm.cosh.f64`, `llvm.tanh.f64`, `llvm.copysign.f64`,
              `llvm.nextafter.f64`), and multi-result functions `Sincos`, `Frexp`, and `Modf` lower to either
              intrinsics/IR sequences or runtime helpers returning aggregates.
            dependencies: [F-7-1, F-7-2, F-7-3, F-7-4, F-7-5, F-8-1, F-8-3]
            status: complete
            tests:
              - src/ami/compiler/driver/time_intrinsics_llvm_test.go
              - src/ami/runtime/host/math/math_test.go

          - id: E-8-5
            statement: |
              As a runtime engineer, I expect deterministic runtime helpers for math multi-returns when intrinsics
              are insufficient or to ensure portability: `ami_rt_math_sincos(double)->{double,double}`,
              `ami_rt_math_frexp(double)->{double,i64}`, and `ami_rt_math_modf(double)->{double,double}` implemented
              in `runtime.ll` using portable IR and LLVM intrinsics where possible.
            dependencies: [F-8-3]
            status: complete
            tests:
              - src/ami/compiler/codegen/llvm/runtime_roundtrip_test.go

          - id: E-8-6
            statement: |
              As a maintainer, I expect removal of `math` builtin stubs and any codegen skips: the compiler should
              import and fully lower/emit `math` without relying on stub packages.
            dependencies: [F-8-1, F-8-3, F-8-4]
            status: complete
            tests: []

          - id: E-8-7
            statement: |
              As a developer, I expect comprehensive tests and documentation for the new capabilities: IR encode tests
              for multi-result calls, LLVM emission tests for aggregate returns and `extractvalue`, and e2e compile
              tests covering `math.Sincos`, `math.Frexp`, and `math.Modf`. Update `docs/language/stdlib/math.md` to
              reflect deterministic behavior and implementation notes.
            dependencies: [F-8-1, F-8-3, F-8-4]
            status: complete
            tests:
              - src/ami/compiler/codegen/llvm/module_test.go
              - tests/e2e (new cases TBD)

  - id: S-8
    name: gpu package
    features:
      - id: F-8-1
        name: GPU Kernel Execution (Transform)
        expectations:
          - id: E-8-1-1
            statement: |
              As a user, I expect a stdlib `gpu` package that enables Transform nodes to execute GPU kernels with
              deterministic integration into the runtime scheduler and event model.
            dependencies: [F-11-23, F-11-22, F-11-11]
            status: complete
            tests:
              - src/ami/runtime/exec/gpu_dispatch_transform_test.go

  - id: S-9
    name: json package
    features:
      - id: F-9-1
        name: JSON Encode/Decode
        expectations:
          - id: E-9-1-1
            statement: |
              As a user, I expect an AMI stdlib `json` package modeled on Go's `encoding/json` basics, implemented with
              AMI semantics and emitted as LLVM. Provide deterministic, pointer-free helpers for encoding and decoding
              common AMI types and structs.
              - json.Encode(v any) (string, error) — returns canonical JSON with stable key ordering.
              - json.Decode[T](s string) (T, error) — decodes into AMI types/Struct; errors are deterministic.
              - Optional bytes variants may use `Owned<slice<uint8>>` in place of string.
            dependencies: [F-11-10, F-11-18]
            status: complete
            tests:
              - src/ami/runtime/host/json/json_encode_decode_test.go
              - src/ami/compiler/driver/stdlib_json_lowering_test.go
              - src/ami/compiler/codegen/llvm/stdlib_json_emit_test.go
          - id: E-9-1-2
            statement: |
              As a maintainer, I expect canonical, deterministic encoding: stable map key ordering, IEEE-754 float
              handling consistent with AMI math semantics, and no raw pointers in exposed APIs. Decoding rejects
              unknown fields in strict mode with clear diagnostics.
            dependencies: [F-11-18]
            status: complete
            tests:
              - src/ami/runtime/host/json/json_canonical_order_test.go
              - src/ami/compiler/driver/stdlib_json_strict_mode_test.go

  - id: S-10
    name: yaml package
    features:
      - id: F-10-1
        name: YAML Encode/Decode
        expectations:
          - id: E-10-1-1
            statement: |
              As a user, I expect an AMI stdlib `yaml` package with a minimal, deterministic surface aligned with AMI
              semantics and emitted as LLVM. Provide helpers similar to Go's yaml libraries while preserving AMI rules.
              - yaml.Encode(v any) (string, error)
              - yaml.Decode[T](s string) (T, error)
              - Optional bytes variants may use `Owned<slice<uint8>>`.
            dependencies: [F-11-10, F-11-18]
            status: complete
            tests:
              - src/ami/runtime/host/yaml/yaml_encode_decode_test.go
              - src/ami/compiler/driver/stdlib_yaml_lowering_test.go
              - src/ami/compiler/codegen/llvm/stdlib_yaml_emit_test.go
          - id: E-10-1-2
            statement: |
              As a maintainer, I expect deterministic YAML emission with a documented subset (no anchors/aliases by
              default), stable ordering where representable, and strict decoding mode that rejects unknown fields with
              clear diagnostics.
            dependencies: [F-11-18]
            status: complete
            tests:
              - src/ami/runtime/host/yaml/yaml_strict_mode_test.go

  - id: S-11
    name: bufio package
    features:
      - id: F-11-1
        name: Buffered Reader/Writer
        expectations:
          - id: E-11-1-1
            statement: |
              As a user, I expect an AMI stdlib `bufio` package, modeled after Go's `bufio`, to provide buffered
              reading/writing with deterministic behavior and AMI semantics (no raw pointers, Owned<T> for buffers,
              capability-aware I/O). Core APIs:
              - type Reader; func bufio.NewReader(src any) (bufio.Reader, error)
              - method Reader.Read(n int) (Owned<slice<uint8>>, error)
              - method Reader.Peek(n int) (Owned<slice<uint8>>, error)
              - method Reader.UnreadByte() error
              - type Writer; func bufio.NewWriter(dst any) (bufio.Writer, error)
              - method Writer.Write(p Owned<slice<uint8>>) (int, error)
              - method Writer.Flush() error
              Backing sources/sinks include AMI `io` handles and in‑memory buffers (Owned<slice<uint8>>). Behavior is
              deterministic with explicit flushes and bounded internal buffers.
            dependencies: [S-1, F-11-10, F-11-18]
            status: ready
            tests:
              - src/ami/runtime/host/bufio/reader_writer_test.go
              - src/ami/compiler/driver/stdlib_bufio_lowering_test.go
              - src/ami/compiler/codegen/llvm/stdlib_bufio_emit_test.go
          - id: E-11-1-2
            statement: |
              As a maintainer, I expect Owned<T>-aware zeroization and no leaks: reads allocate Owned<slice<uint8>>
              and obey RAII; writers accept Owned buffers or strings converted to Owned internally, with documented
              ownership transfer rules. All operations return deterministic errors.
            dependencies: [F-11-10, F-11-18]
            status: ready
            tests:
              - src/ami/compiler/driver/raii_bufio_owned_test.go
      - id: F-11-2
        name: Scanner (minimal)
        expectations:
          - id: E-11-2-1
            statement: |
              As a user, I expect a minimal `bufio.Scanner` to iterate buffered input with a default split on lines.
              APIs:
              - type Scanner; func bufio.NewScanner(r bufio.Reader) (bufio.Scanner, error)
              - method Scanner.Scan() bool
              - method Scanner.Text() string
              - method Scanner.Bytes() Owned<slice<uint8>>
              - method Scanner.Err() error
              Deterministic limits for token size are documented and enforce errors rather than panics.
            dependencies: [S-1, F-11-10, F-11-18]
            status: ready
            tests:
              - src/ami/runtime/host/bufio/scanner_test.go
              - src/ami/compiler/driver/stdlib_bufio_scanner_lowering_test.go
          - id: E-8-1-2
            statement: |
              As a user, I expect that if the compiler detects a program imports the `gpu` package and uses it in an AMI
              program, the compiler will generate LLVM code which will execute at program startup to detect the GPU type
              on a host running the program; the program should use this global GPU detection to ensure the binary
              executable invokes the proper GPU facilities (e.g. CUDA, Apple Metal, etc.); the compiler/optimizer should
              eliminate certain GPU facilities known to be impossible.  For example: when compiling a darwin/arm64
              binary, the compiler would only include Apple Metal, while compiling for darwin/amd64, ROCm support would
              be necessary.  Likewise, when compiling linux/amd64, CUDA or ROCm would be supported possibilities. Any
              resulting binary should have runtime conditional logic to enable/disable the detected GPU platform.
            dependencies: [F-8-1]
            status: ready
            tests: []


      - id: F-8-2
        name: CUDA Backend (Cuda*)
        expectations:
          - id: E-8-2-1
            statement: |
              As a user, I expect CUDA discovery helpers: `gpu.CudaAvailable() bool` and `gpu.CudaDevices() 
              []gpu.Device`.
            dependencies: []
            status: ready
            tests:
              - src/ami/runtime/host/gpu/cuda_discovery_test.go
              - src/ami/runtime/host/gpu/cuda_env_test.go

          - id: E-8-2-2
            statement: |
              As a user, I expect context management: `gpu.CudaCreateContext(dev gpu.Device) (gpu.Context, error)` and
              `gpu.CudaDestroyContext(ctx gpu.Context) error` with Owned<T> semantics.
            dependencies: [F-11-21]
            status: ready
            tests:
              - src/ami/runtime/host/gpu/cuda_owned_handles_test.go
              - src/ami/runtime/host/gpu/stub_paths_test.go
              - src/ami/runtime/host/gpu/cuda_error_paths_test.go
          - id: E-8-2-3
            statement: |
              As a user, I expect buffer and transfer APIs: `gpu.CudaAlloc(n int) (gpu.Buffer, error)`,
              `gpu.CudaFree(buf gpu.Buffer) error`, `gpu.CudaMemcpyHtoD(dst gpu.Buffer, src []byte) error`, and
              `gpu.CudaMemcpyDtoH(dst []byte, src gpu.Buffer) error` to perform argument validation and deterministic
              erroring on invalid inputs under stubbed backends.
            dependencies: [F-11-21]
            status: complete
            tests:
              - src/ami/runtime/host/gpu/cuda_memcpy_arg_validation_test.go
              - src/ami/runtime/host/gpu/cuda_alloc_arg_validation_test.go
              - src/ami/runtime/host/gpu/stub_paths_test.go
          - id: E-8-2-4
            statement: |
              As a user, I expect kernel APIs with deterministic validation: `gpu.CudaLoadModule`, `gpu.CudaGetKernel`,
              and `gpu.CudaLaunchKernel` validate inputs and signal `ErrInvalidHandle` for invalid args under stubs.
            dependencies: [F-11-21]
            status: complete
            tests:
              - src/ami/runtime/host/gpu/cuda_memcpy_arg_validation_test.go
              - src/ami/runtime/host/gpu/cuda_alloc_arg_validation_test.go
              - src/ami/runtime/host/gpu/launch_blocking_test.go

          - id: E-8-2-3
            statement: |
              As a user, I expect buffer and transfer APIs: `gpu.CudaAlloc(n int) (gpu.Buffer, error)`,
              `gpu.CudaFree(buf gpu.Buffer) error`, `gpu.CudaMemcpyHtoD(dst gpu.Buffer, src []byte) error`, and
              `gpu.CudaMemcpyDtoH(dst []byte, src gpu.Buffer) error`.
            dependencies: [F-11-21]
            status: complete
            tests: []

          - id: E-8-2-4
            statement: |
              As a user, I expect kernel APIs: `gpu.CudaLoadModule(ptx string) (gpu.Module, error)`,
              `gpu.CudaGetKernel(mod gpu.Module, name string) (gpu.Kernel, error)`, and
              `gpu.CudaLaunchKernel(ctx gpu.Context, k gpu.Kernel, grid, block [3]uint32, sharedMem uint32, 
              args ...any) error`.
            dependencies: [F-11-21]
            status: complete
            tests: []

      - id: F-8-3
        name: Apple Metal Backend (Metal*)
        expectations:
          - id: E-8-3-1
            statement: |
              As a user, I expect Metal discovery helpers: `gpu.MetalAvailable() bool` and 
              `gpu.MetalDevices() []gpu.Device`.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/gpu/metal_darwin_test.go
              - src/ami/runtime/host/gpu/metal_scalar_test.go
              - src/ami/runtime/host/gpu/metal_slice_i8_test.go
              - src/ami/runtime/host/gpu/metal_slice_i32_test.go
              - src/ami/runtime/host/gpu/metal_slice_u16_test.go
              - src/ami/runtime/host/gpu/metal_slice_u32_test.go
              - src/ami/runtime/host/gpu/metal_slice_u8_test.go
              - src/ami/runtime/host/gpu/metal_slice_f32_test.go
              - src/ami/runtime/host/gpu/metal_release_test.go

          - id: E-8-3-2
            statement: |
              As a user, I expect context management: `gpu.MetalCreateContext(dev gpu.Device) (gpu.Context, error)` and
              `gpu.MetalDestroyContext(ctx gpu.Context) error` with Owned<T> semantics.
            dependencies: [F-11-21]
            status: complete
            tests:
              - src/ami/runtime/host/gpu/metal_darwin_test.go
              - src/ami/runtime/host/gpu/metal_release_test.go

          - id: E-8-3-3
            statement: |
              As a user, I expect shader and pipeline APIs: `gpu.MetalCompileLibrary(src string) (gpu.Library, error)`,
              `gpu.MetalCreatePipeline(lib gpu.Library, name string) (gpu.Pipeline, error)`, and
              `gpu.MetalDispatch(ctx gpu.Context, p gpu.Pipeline, grid, threadsPerGroup [3]uint32, args ...any) error`.
            dependencies: [F-11-21]
            status: complete
            tests:
              - src/ami/runtime/host/gpu/metal_compute_test.go
              - src/ami/runtime/host/gpu/metal_scalar_test.go
              - src/ami/runtime/host/gpu/metal_slice_i8_test.go
              - src/ami/runtime/host/gpu/metal_slice_i32_test.go
              - src/ami/runtime/host/gpu/metal_slice_u16_test.go
              - src/ami/runtime/host/gpu/metal_slice_u32_test.go
              - src/ami/runtime/host/gpu/metal_slice_u8_test.go
              - src/ami/runtime/host/gpu/metal_slice_f32_test.go
              - src/ami/runtime/host/gpu/blocking_test.go

          - id: E-8-3-4
            statement: |
              As a user, I expect buffer and transfer APIs: `gpu.MetalAlloc(n int) (gpu.Buffer, error)`,
              `gpu.MetalFree(buf gpu.Buffer) error`, `gpu.MetalCopyToDevice(dst gpu.Buffer, src []byte) error`, and
              `gpu.MetalCopyFromDevice(dst []byte, src gpu.Buffer) error`.
            dependencies: [F-11-21]
            status: complete
            tests:
              - src/ami/runtime/host/gpu/metal_release_test.go
              - src/ami/runtime/host/gpu/metal_scalar_u8_test.go
              - src/ami/runtime/host/gpu/metal_slice_f32_test.go

      - id: F-8-4
        name: OpenCL Backend (OpenCL*)
        expectations:
          - id: E-8-4-1
            statement: |
              As a user, I expect OpenCL discovery helpers: `gpu.OpenCLAvailable() bool` and 
              `gpu.OpenCLPlatforms() []gpu.Platform` with device enumeration.
            dependencies: []
            status: complete
            tests:
              - src/ami/runtime/host/gpu/opencl_discovery_test.go
              - src/ami/runtime/host/gpu/opencl_env_test.go
              - src/ami/runtime/host/gpu/opencl_devices_test.go

          - id: E-8-4-2
            statement: |
              As a user, I expect context, buffers, and kernels: `gpu.OpenCLCreateContext(p gpu.Platform) 
              (gpu.Context, error)`, `gpu.OpenCLAlloc(n int) (gpu.Buffer, error)`, `gpu.OpenCLFree(buf gpu.Buffer) 
              error`,`gpu.OpenCLBuildProgram(src string) (gpu.Program, error)`, `gpu.OpenCLGetKernel(prog gpu.Program, 
              name string) (gpu.Kernel, error)`, and `gpu.OpenCLLaunchKernel(ctx gpu.Context, k gpu.Kernel, global, 
              local [3]size_t, args ...any) error`.
            dependencies: [F-11-21]
            status: ready
            tests:
              - src/ami/runtime/host/gpu/opencl_alloc_arg_validation_test.go
              - src/ami/runtime/host/gpu/opencl_launch_arg_validation_test.go
              - src/ami/runtime/host/gpu/opencl_owned_handles_test.go
              - src/ami/runtime/host/gpu/opencl_error_paths_test.go

      - id: F-8-5
        name: Common Opaque Handles and Ownership
        expectations:
          - id: E-8-5-1
            statement: |
              As a user, I expect common opaque types `gpu.Context`, `gpu.Buffer`, `gpu.Module/Library`,
              `gpu.Program`, `gpu.Kernel/Pipeline`, `gpu.Device/Platform` to follow Owned<T> semantics with
              zeroization on release and deterministic erroring on double-free.
            dependencies: [F-11-21]
            status: ready
            tests:
              - src/ami/runtime/host/gpu/gpu_stub_test.go
              - src/ami/runtime/host/gpu/cuda_owned_handles_test.go
              - src/ami/runtime/host/gpu/opencl_owned_handles_test.go

  - id: F-8-6
        name: Determinism, Scheduling, and Diagnostics
        expectations:
          - id: E-8-6-1
            statement: |
              As a user, I expect GPU operations to integrate deterministically with the runtime scheduler and event
              model; backend availability is probed explicitly, and launches produce clear diagnostics on failure.
            dependencies: [F-11-23, F-11-22]
            status: complete
            tests:
              - src/ami/runtime/host/gpu/explain_test.go
              - src/ami/runtime/host/gpu/gpu_diag_test.go

bug_reports:
  - id: B-2025-10-04-compiler-pipeline-parens
    title: Parser requires empty parameter list in pipeline declaration; conflicts with configured node attributes
    summary: |
      When compiling examples/correct, the compiler emits E_PARSE_SYNTAX beginning with
      "expected '(', got '{'" at the pipeline declaration line. The parser currently requires an
      empty parameter list after the pipeline name (e.g., `pipeline PeriodicInterval()`), which
      causes a cascade of follow-on parse errors when the source uses `pipeline PeriodicInterval {`.

      In this specific case, the behavior also conflicts with the authoritative docx semantics that
      require configured pipeline nodes. The program specifies attributes for nodes (e.g., `Ingress(name=..., in=..., worker=..., ...)`),
      but the compiler expectation effectively aligns with an empty attribute list pattern like `Ingress()`.
      The parser should accept configured nodes and not require an empty parameter list on the pipeline declaration.
    status: ready
    repro:
      - step: Ensure repo is on main with current CLI
      - step: cd examples/correct
      - step: ami build
      - observe:
          - code: E_PARSE_SYNTAX
          - message: "expected '(', got '{'"
          - file: examples/correct/src/main.ami
          - notes: Subsequent messages include "expected function name, got '('", "expected '{', got ')'", and "unexpected token in error block: 'return'" due to cascading.
    config:
      workspace: examples/correct/ami.workspace
      toolchain:
        command: ami build
        mode: default (no special flags)
      environment:
        os: darwin (reproducible on others per toolchain targets)
        docx: docs/Asynchronous Machine Interface.docx (authoritative semantics)
    expected_behavior: |
      - Parser accepts pipeline declarations without a required empty parameter list (either allow `pipeline Name {` or
        update examples/docs to reflect a mandatory `pipeline Name() {` if that is the intended grammar).
      - Parser accepts configured node invocations with attributes (e.g., `Ingress(name=..., in=..., worker=..., ...)`).
    actual_behavior: |
      - Parser requires `()` after the pipeline name; source using `pipeline <Name> {` fails with E_PARSE_SYNTAX.
      - Reported diagnostics (first error): "expected '(', got '{'" at the pipeline header.
    workaround: |
      Add an empty parameter list to the pipeline declarations (e.g., `pipeline PeriodicInterval() { ... }`,
      `pipeline PeriodicCounter() { ... }`) to unblock parsing while the grammar/doc alignment is addressed.
    references:
      - file: examples/correct/src/main.ami
      - diag_codes: [E_PARSE_SYNTAX]
      - source: src/ami/compiler/parser/Parser.parsePipelineDecl.go
    tests: []
  - id: B-2025-10-04-missing-fallthrough
    title: Missing parser/AST/lowering for `fallthrough` in switch cases
    summary: |
      While `KwFallthrough` is defined in the tokenizer, the compiler lacks parsing, AST, and lowering support for
      `fallthrough` within `switch` statements. There is no `FallthroughStmt` node, no handling in the function block
      parser, and no CFG construction to chain case bodies via fallthrough. This prevents AMI sources from expressing
      Go-like fallthrough semantics in switch-case constructs.
    status: ready
    repro:
      - code: |
          package app
          func F(x int){
            switch x {
            case 1:
              // work
              fallthrough
            case 2:
              // more work
            }
          }
      - step: ami build
      - observe: parse error on `fallthrough` (and `switch` itself if not yet implemented).
    config:
      references:
        - parser: src/ami/compiler/parser/Parser.parseFuncBlock.go (no case for KwFallthrough)
        - ast: src/ami/compiler/ast (no FallthroughStmt)
        - lowering: src/ami/compiler/driver/lower_block_cfg.go (no chaining of case blocks via fallthrough)
        - token: src/ami/compiler/token/kind.go (KwFallthrough present)
        - related: B-2025-10-04-missing-switch-case
    expected_behavior: |
      - Parse `fallthrough` only inside switch cases; emit CFG to continue into the next case body unconditionally.
      - Enforce rules (e.g., last case cannot fall through if there is no following case); emit clear diagnostics.
    actual_behavior: |
      - `fallthrough` is not recognized; there is no AST or lowering support.
    workaround: |
      - Duplicate code or refactor cases into shared helpers; no direct fallthrough equivalent exists without switch.
    tests: []
  - id: B-2025-10-04-missing-continue
    title: Missing parser/AST/lowering for `continue` statements
    summary: |
      The tokenizer defines `KwContinue`, but the AMI compiler does not implement `continue` parsing or lowering. There
      is no `ContinueStmt` in the AST, no handling in `parseFuncBlock`, and no lowering in `lowerBlockCFG` to jump to
      the loop’s next-iteration target. As a result, AMI sources cannot use `continue` to advance to the next loop
      iteration. (Note: general `for` loop support is also missing; see B-2025-10-04-missing-for-loop.)
    status: ready
    repro:
      - code: |
          package app
          func F(){
            for {
              continue
            }
          }
      - step: ami build
      - observe: parse error due to missing `for`/`continue` handling; once `for` exists, `continue` remains unparsed.
    config:
      references:
        - parser: src/ami/compiler/parser/Parser.parseFuncBlock.go (no case for KwContinue)
        - ast: src/ami/compiler/ast (no ContinueStmt node)
        - lowering: src/ami/compiler/driver/lower_block_cfg.go (no continue lowering)
        - token: src/ami/compiler/token/kind.go (KwContinue present)
    expected_behavior: |
      - Parse `continue` and lower to a CFG jump targeting the loop’s update/head block (per loop form), with correct
        nesting/labels when present. Emit diagnostics for invalid use outside loops.
    actual_behavior: |
      - `continue` is not recognized; there is no AST or lowering support.
    workaround: |
      - None directly; restructure conditions to skip work via `if` blocks or refactor with early `return` where valid.
    tests: []
  - id: B-2025-10-04-missing-break
    title: Missing parser/AST/lowering for `break` statements
    summary: |
      The tokenizer defines `KwBreak`, but the AMI compiler does not implement `break` parsing or lowering. There is no
      `BreakStmt` in the AST, no handling in `parseFuncBlock`, and no lowering in `lowerBlockCFG` to jump to loop/switch
      exit blocks. As a result, AMI sources cannot use `break` to exit from loops or switch statements.
    status: ready
    repro:
      - code: |
          package app
          func F(){
            for { break }
          }
      - step: ami build
      - observe: parse error (unexpected token 'break') due to missing parser support; or generic block error.
    config:
      references:
        - parser: src/ami/compiler/parser/Parser.parseFuncBlock.go (no case for KwBreak)
        - ast: src/ami/compiler/ast (no BreakStmt node)
        - lowering: src/ami/compiler/driver/lower_block_cfg.go (no break lowering)
        - token: src/ami/compiler/token/kind.go (KwBreak present)
    expected_behavior: |
      - Parse `break` and lower to CFG jumps that target the immediately enclosing loop/switch exit block, with correct
        nesting and labels (when supported). Emit stable diagnostics for invalid use outside of loop/switch.
    actual_behavior: |
      - `break` is not recognized; there is no AST or lowering support.
    workaround: |
      - None directly; restructure with conditionals and returns, which changes semantics.
    tests: []
  - id: B-2025-10-04-missing-switch-case
    title: Missing parser/lowering for switch/case/default (and fallthrough)
    summary: |
      The tokenizer defines `KwSwitch`, `KwCase`, `KwDefault`, and `KwFallthrough`, but the compiler does not implement
      `switch` parsing or lowering. There is no `SwitchStmt`/`CaseClause`/`FallthroughStmt` in the AST, no handling in
      `parseFuncBlock`, and no lowering path in `lowerBlockCFG`. Fallthrough semantics are not implemented. As a
      result, AMI sources cannot express `switch` statements or use `fallthrough`.
    status: ready
    repro:
      - code: |
          package app
          func F(x int){
            switch x {
            case 0:
              return
            case 1, 2:
              // work
              fallthrough
            default:
              // other
            }
          }
      - step: ami build
      - observe: parse error in function block (unexpected token 'switch'/'case') due to no parser support.
    config:
      references:
        - parser: src/ami/compiler/parser/Parser.parseFuncBlock.go (no case for KwSwitch/KwCase/KwDefault/KwFallthrough)
        - ast: src/ami/compiler/ast (no SwitchStmt/Case/Fallthrough nodes)
        - lowering: src/ami/compiler/driver/lower_block_cfg.go (no switch lowering)
        - token: src/ami/compiler/token/kind.go (keywords present)
    expected_behavior: |
      - Parse switch with expression or empty (switch true) and case lists (single or comma‑separated), plus `default`.
      - Support `fallthrough` semantics; emit CFG via chained CondBr or a small dispatch tree with PHIs at joins.
      - Provide diagnostics for duplicate/overlapping cases and unreachable default, with stable positions.
    actual_behavior: |
      - `switch` is not recognized; there is no AST or lowering support; codegen receives no switch CFG.
    workaround: |
      - Use nested `if`/`else if`/`else` conditionals. No direct `fallthrough` equivalent exists without switch.
    tests: []
  - id: B-2025-10-04-missing-for-loop
    title: Missing parser/lowering for `for` loops; break/continue unsupported
    summary: |
      Although the tokenizer defines `KwFor`, the AMI compiler does not implement `for` loop parsing or lowering. There
      is no `ForStmt` in the AST, no parser handling in `parseFuncBlock`, and no lowering path in `lowerBlockCFG` for
      loop constructs. IR contains `OpLoop` and `Goto`, but these are only used for tail‑call/mutual recursion
      elimination (SCC) in `lowerFuncDeclWithSCC`, not user‑written loops. As a result, AMI sources cannot express
      iterative loops or use `break`/`continue`.
    status: ready
    repro:
      - code: |
          package app
          func F(){
            for i = 0; i < 3; i = i + 1 {
              // work
            }
          }
      - step: ami build
      - observe: parse error in function block (no `for` handling) or generic "unexpected token in block" diagnostics.
    config:
      references:
        - parser: src/ami/compiler/parser/Parser.parseFuncBlock.go (no case for KwFor)
        - ast: src/ami/compiler/ast (no ForStmt/Break/Continue nodes)
        - lowering: src/ami/compiler/driver/lower_block_cfg.go (no loop lowering); src/ami/compiler/driver/lower_func.go (OpLoop used only for TCO)
        - token: src/ami/compiler/token/kind.go (KwFor, KwBreak, KwContinue present but unused in parser)
    expected_behavior: |
      - Parse classic `for init; cond; post {}` and simplified forms `for cond {}`, `for {}`; optionally plan `for range`.
      - Implement `break`/`continue` lowering via labeled CFG blocks; ensure deterministic semantics and positions
        for diagnostics; emit LLVM using existing CondBr/Goto/Phi patterns.
      - Add unit tests for parser, lowering (CFG shape), and LLVM emission (branches/phis), including nested loops and
        break/continue paths.
    actual_behavior: |
      - `for` loops are not recognized; no AST or lowering support; IR contains no loop blocks for user code.
    workaround: |
      - None in AMI source; users cannot express loops and must rely on recursion (which is not ergonomic and may be
        optimized differently).
    tests: []
  - id: B-2025-10-04-errorpipeline-undeclared-onerror
    title: onError references undefined error pipeline; error pipelines must be declared and end in egress
    summary: |
      The examples reference an error pipeline via `onError=ErrorPipeline` without declaring a corresponding error
      pipeline. Per the docx, error pipelines must be declared and must end with `egress`. The current compiler parses
      `onError=...` as a generic attribute but does not validate that the named error pipeline exists or that its steps
      satisfy the required structure. Semantics currently validate only inlined error blocks within a pipeline body
      (see AnalyzeErrorSemantics), not references by name.
    status: ready
    repro:
      - file: examples/correct/src/main.ami
      - step: Observe multiple occurrences of `onError=ErrorPipeline` in PeriodicInterval/PeriodicCounter steps
      - step: ami build (parsing issues may trigger earlier; once resolved, `onError` remains unvalidated)
      - observe: no diagnostic specifically indicating an undefined error pipeline or missing `egress` on the target
    config:
      references:
        - docs: docs/Asynchronous Machine Interface.docx (error pipelines must be declared and terminate with egress)
        - sem: src/ami/compiler/sem/errpipeline.go (validates only inner error blocks)
        - diags: docs/diag-codes.md (E_ERRPIPE_START_INVALID, E_ERRPIPE_END_EGRESS exist for structure)
    expected_behavior: |
      - When `onError=<Name>` is present, validate that `<Name>` resolves to a declared error pipeline (or an inlined
        error block bound to the pipeline), and that the error pipeline ends with `egress`.
      - Emit a clear diagnostic for undefined error pipeline references (e.g., E_ERRPIPE_UNDECLARED) and structural
        issues (E_ERRPIPE_END_EGRESS / E_ERRPIPE_START_INVALID) as applicable.
      - Embed error pipeline metadata in IR/LLVM as today for declared/valid error pipelines.
    actual_behavior: |
      - `onError=...` is parsed as an attribute without cross-reference validation to a declared error pipeline; no
        targeted diagnostic is emitted for undefined references.
    workaround: |
      - Use an inlined error block inside the pipeline declaration that ends with `egress`, or omit `onError` and rely
        on the runtime's default ErrorPipeline until named references are validated.
    tests: []
  - id: B-2025-10-04-node-kvstore-state-identifier
    title: Node KV store access via `state.get/set` not implemented; provide node-scoped `state` identifier per docx
    summary: |
      The docx specifies a node-scoped key/value store accessible from worker code via a special `state` identifier
      (e.g., `state.get(key, default)` / `state.set(key, value)`). While the tokenizer recognizes `state` as a keyword,
      the compiler/semantics do not wire a node KV store into worker scope and calls are not resolvable from AMI code.
      A runtime KV store exists (`docs/toolchain/runtime-kvstore.md`), but there is no language-level binding that
      exposes a per-node namespace to workers. Examples using `state.get/set` therefore fail to parse/resolve.
    status: ready
    repro:
      - file: examples/correct/src/main.ami
      - code: |
          worker=func(_ Event<time.Time>) (Event<uint64>, error ){
            const defaultValue uint64 = 0
            count := strconv.AtoUint64(state.get("counter", defaultValue))
            state.set("counter", count++)
            return count
          }
      - step: ami build
      - observe: unresolved identifier or semantics failure for `state.get`/`state.set` (blocked earlier by other parse
          issues; once unblocked, `state` remains unimplemented as node KV in AMI sources)
    config:
      references:
        - token: src/ami/compiler/token/kind.go (maps "state" → KwState)
        - runtime: docs/toolchain/runtime-kvstore.md (process/global stores exist)
        - docx: docs/Asynchronous Machine Interface.docx (node KV via `state` in workers)
    expected_behavior: |
      - Provide a node-scoped KV store bound to `state` in worker scope with operations like `get(key, default)` and
        `set(key, value)`, consistent with AMI semantics (deterministic, pointer-free, capability/trust boundaries).
      - Define lifecycle and namespacing (`pipeline/node`) and ensure scheduler-safe access; emit LLVM or use
        host-backed helpers consistent with existing stdlib patterns.
      - Surface diagnostics and debug artifacts (e.g., KV metrics/keys under build/debug when verbose/test flags on).
    actual_behavior: |
      - No language-level `state` binding; workers cannot access a node KV store directly. `state` is tokenized but
        not implemented in parser/semantics/codegen.
    workaround: |
      - None from AMI sources today. Tests and runtime components can use the runtime KV store directly, but AMI
        programs lack a stable `state` identifier to reach a node-scoped store.
    tests: []
  - id: B-2025-10-04-stdlib-go-parity-strings-strconv
    title: Missing AMI stdlib parity for Go `strings` and `strconv`; add AMI modules with LLVM-backed codegen
    summary: |
      AMI sources currently cannot use Go-like string processing and numeric parsing/formatting helpers such as
      `strings.*` and `strconv.*` because equivalent AMI stdlib modules are not implemented. The authoritative goal is
      to provide these features under AMI semantics (pointer-free, deterministic, capability-aware), and lower them to
      LLVM via the AMI compiler. Without these modules, examples attempting to call `strconv.*` or `strings.*` fail at
      name resolution/semantics or codegen.
    status: ready
    repro:
      - code: |
          package app
          func W(ev Event<string>) (Event<string>, error) {
            let s = " 123 "
            let t = strings.TrimSpace(s)
            let n, err = strconv.Atoi(t)
            _ = n; _ = err
            return ev, nil
          }
          pipeline P() { Transform(worker=W); egress }
      - step: ami build
      - observe: unresolved module/function diagnostics (e.g., worker/ident undefined) for `strings.*` / `strconv.*`
    config:
      references:
        - docs: docs/language/stdlib/* (time, io, os, math exist; strings/strconv missing)
        - sem: name/type resolution and worker checks will flag undefined refs
        - backend: src/ami/compiler/codegen/llvm/* (needs lowering hooks for new stdlib functions)
    expected_behavior: |
      - Provide AMI stdlib modules `strings` and `strconv` with a minimal, prioritized surface:
        - strings: TrimSpace, HasPrefix, HasSuffix, Contains, Split, Join, ToUpper/Lower, Compare, etc.
        - strconv: Atoi/ParseInt/ParseUint/ParseFloat, FormatInt/Uint/Float, Itoa, etc.
      - Enforce AMI constraints (no raw pointers; deterministic behavior; clear error returns) and emit LLVM IR via
        intrinsics where available or host-backed runtime helpers consistent with existing stdlib patterns.
      - Document APIs under docs/language/stdlib/ and add tests to `src/ami/runtime/host/*` or compiler driver tests
        validating lowering and runtime behavior.
    actual_behavior: |
      - No AMI `strings`/`strconv` modules; calls fail to resolve or are rejected by semantics checks.
    workaround: |
      - Implement local helpers within the package; this does not provide shared stdlib or codegen coverage.
    tests: []
  - id: B-2025-10-04-edge-capacity-fieldnames
    title: Edge capacity fields should be minCapacity/maxCapacity (not min/max)
    summary: |
      For FIFO/LIFO edge configurations, the correct attribute names are `minCapacity` and `maxCapacity`. The current
      semantics layer recognizes only `min` and `max` (and flags others with `E_EDGE_PARAM_UNKNOWN`), and docs examples
      use `min`/`max`. This diverges from the intended API and underlying edge specs which model `MinCapacity`/
      `MaxCapacity`.
    status: ready
    repro:
      - code: |
          package app
          pipeline P() {
            Collect(
              in=edge.FIFO(minCapacity=5, maxCapacity=10, backpressure=block),
            )
            egress
          }
      - step: ami build
      - observe:
          - code: E_EDGE_PARAM_UNKNOWN
          - message: unknown edge parameter: minCapacity / maxCapacity
    config:
      references:
        - sem: src/ami/compiler/sem/edges.go (accepts only min/max/backpressure)
        - edge: src/ami/compiler/edge/fifo.go, src/ami/compiler/edge/lifo.go (MinCapacity/MaxCapacity fields)
        - docs: docs/language/edges.md (examples show min/max; needs update)
    expected_behavior: |
      - Accept `minCapacity`/`maxCapacity` as canonical attribute names for FIFO/LIFO edges.
      - Optionally support `min`/`max` as legacy aliases with a warning (deprecation path), or normalize both to the
        same fields in debug artifacts.
    actual_behavior: |
      - Only `min`/`max` are recognized; `minCapacity`/`maxCapacity` produce unknown-parameter diagnostics.
    workaround: |
      - Use `min`/`max` until compiler and docs are updated to treat `minCapacity`/`maxCapacity` as canonical.
    tests: []
  - id: B-2025-10-04-multipath-inputs-brackets-docx
    title: Docx mismatch — MultiPath inputs use bracketed lists `inputs=[ ... ]`
    summary: |
      The correct syntax for Collect multipath inputs in AMI is a named argument with a bracketed list:
      `edge.MultiPath(inputs=[ edge.FIFO(...), edge.Pipeline(...), ... ], ...)`. The authoritative docx either omits
      this or implies a different form. The implementation, examples, and debug indices expect a list of inputs and
      surface them accordingly. The docx should be updated to state that `inputs=[ ... ]` is the canonical form.
    status: ready
    repro:
      - step: Open examples/correct/src/main.ami and find the Collect MultiPath block
      - code: |
          in=edge.MultiPath(
            inputs=[
              edge.FIFO(...),
              edge.Pipeline(...),
            ],
            // merge.* attributes ...
          )
      - step: Compare with the docx description of Collect inputs (does not show bracketed list)
    config:
      references:
        - example: examples/correct/src/main.ami
        - docs: docs/toolchain/merge.md (scaffold describes MultiPath on Collect)
        - docs: docs/language/edges.md (debug indices show multipath inputs)
        - docx: docs/Asynchronous Machine Interface.docx (needs update for inputs=[ ... ])
    expected_behavior: |
      - Documentation reflects `edge.MultiPath(inputs=[ ... ], merge.*...)` as the supported/required syntax.
    actual_behavior: |
      - Docx lacks or contradicts the bracketed `inputs=[ ... ]` form used by the implementation and examples.
    workaround: |
      - Use the bracketed list form in sources; track documentation update to align the spec with implementation.
    tests: []
  - id: B-2025-10-04-collect-merge-api-mismatch
    title: Collect merge config must use merge.* API; example uses merge=Sort(...)
    summary: |
      The authoritative docx and language docs specify Collect merge configuration via the stdlib `merge.*` API,
      e.g., `merge.Sort(field[, order])`, `merge.Window(n)`, `merge.Key(field)`, `merge.Stable()`, etc. The
      examples/correct source instead uses a named argument `merge=Sort(algorithm=..., window=..., key=event.Created)`,
      which is not the documented API and will not normalize to the expected `mergeNorm` scaffold (Buffer/Stable/Sort).
      This mismatch prevents downstream semantics/lint from recognizing the intended merge configuration and may be
      rejected as unknown/invalid attributes.
    status: ready
    repro:
      - step: Open examples/correct/src/main.ami
      - step: Locate PeriodicCounter Collect multipath configuration
      - code: |
          in=edge.MultiPath(
            inputs=[ ... ],
            merge=Sort(
              algorithm=ascendingTimeStamp,
              window=120,
              key=event.Created,
            ),
          )
      - step: Compare with docx/docs which show `merge.Sort(ts, asc)`, `merge.Window(n)`, `merge.Key(field)` forms
      - step: ami build (note: parsing bugs may block; see pipeline parens bugs)
    config:
      workspace: examples/correct/ami.workspace
      toolchain:
        command: ami build
        mode: default
      references:
        - doc: docs/toolchain/merge.md (Merge Attributes and MultiPath)
        - doc: docs/language/edges.md (Collect example with merge.Buffer/Stable/Sort)
        - file: examples/correct/src/main.ami
    expected_behavior: |
      - Collect multipath accepts and normalizes stdlib `merge.*` calls (e.g., `merge.Sort(ts, asc)`,
        `merge.Window(120)`, `merge.Key(id)`) and surfaces them in debug artifacts (edges/pipelines `mergeNorm`).
      - If non-stdlib forms are provided (e.g., `merge=Sort(...)`), the compiler emits clear `E_MERGE_ATTR_*` diagnostics.
    actual_behavior: |
      - The example uses `merge=Sort(...)`, which does not match the `merge.*` API described in the docx and
        docs, leading to either parse acceptance with wrong shape or rejection; semantics cannot normalize as intended.
    workaround: |
      - Replace the named argument with explicit stdlib calls within the Collect context, e.g.,
        `merge.Sort(event.Created, asc), merge.Window(120), merge.Key(event.Created)`. If a Buffer policy is intended,
        add `merge.Buffer(capacity, policy)` as documented.
    tests: []
  - id: B-2025-10-04-examples-correct-periodiccounter-worker-sig
    title: examples/correct PeriodicCounter ingress worker returns count but signature declares (Event<uint64>, error)
    summary: |
      In examples/correct/src/main.ami, the PeriodicCounter pipeline's ingress specifies a worker with the signature
      `(Event<uint64>, error)` but the function body returns only `count` (a `uint64`). This is inconsistent. Under the
      current compiler semantics, workers must return `(Event<U>, error)` and the body must return an `Event<U>` value.
      Under the docx semantics, workers should return `(U, error)` and the VM emits `Event<U>`; in that case the
      example’s function signature should be `(uint64, error)` rather than `(Event<uint64>, error)`.
    status: ready
    repro:
      - step: Open examples/correct/src/main.ami
      - step: Locate PeriodicCounter ingress worker
      - code: |
          worker=func(_ Event<time.Time>) (Event<uint64>, error ){
              const defaultValue uint64 = 0
              count:=strconv.AtoUint64(state.get("counter",defaultValue))
              state.set("counter",count++)
              return count
          }
      - step: ami build (note: pipeline parens and inline func parsing bugs may block earlier; see related bugs)
      - observe: Signature and return mismatch (would be flagged once parser accepts the file and inline worker forms)
    config:
      workspace: examples/correct/ami.workspace
      toolchain:
        command: ami build
        mode: default
      references:
        - file: examples/correct/src/main.ami
        - sem: src/ami/compiler/sem/workers.go (current check expects `(Event<U>, error)`)
        - docx: docs/Asynchronous Machine Interface.docx (VM emits Event<T>/Error<E>)
        - related: B-2025-10-04-worker-returns-payload
    expected_behavior: |
      - If following current compiler semantics: keep `(Event<uint64>, error)` signature and return an `Event<uint64>`
        (plus error), not a bare `uint64`.
      - If aligning with docx: change the worker signature to `(uint64, error)` and allow the VM to emit `Event<uint64>`.
    actual_behavior: |
      - Function signature declares `(Event<uint64>, error)` but returns `count` (uint64), violating the declared
        result type.
    workaround: |
      - Short term: wrap `count` into an appropriate `Event<uint64>` value and return `(Event<uint64>, nil)` to satisfy
        the current signature; or change the signature to `(uint64, error)` once the compiler accepts docx-style
        worker returns.
    tests: []
  - id: B-2025-10-04-worker-returns-payload
    title: Worker must return payload type and error; VM emits Event<T>/Error<E>
    summary: |
      The authoritative docx specifies that all workers return the payload type `T` and `error`, and the
      worker VM is responsible for emitting `Event<T>` on success and `Error<E>` on failure. The current
      compiler/semantics require workers to return `(Event<U>, error)` and emit `E_WORKER_SIGNATURE` when
      a worker returns `(U, error)`. This diverges from the docx and prevents writing workers that return the
      bare payload type.
    status: ready
    repro:
      - step: Create an AMI file with a worker returning `(uint64, error)` and a simple pipeline using it
      - code: |
          package app
          func W(ev Event<uint64>) (uint64, error) { return 0, nil }
          pipeline P() {
            Transform(worker=W)
            Egress()
          }
      - step: ami build
      - observe:
          - code: E_WORKER_SIGNATURE
          - message: "invalid worker signature: want func(Event<T>)->(Event<U>, error)"
    config:
      toolchain:
        command: ami build
        mode: default
      references:
        - docx: docs/Asynchronous Machine Interface.docx (worker VM emits Event<T>/Error<E>)
        - sem: src/ami/compiler/sem/workers.go (enforces Event<U> return)
        - docs: docs/language/language-workers.md (needs reconciliation with docx)
    expected_behavior: |
      - Accept workers that return `(U, error)` where `U` is the payload type; the runtime/VM wraps the result
        into `Event<U>` on success or emits an appropriate error channel/message on failure.
      - Existing `(Event<U>, error)` workers may continue to be supported for migration if desired, but should not be
        required by signature checks when the docx mandates `(U, error)`.
    actual_behavior: |
      - Workers returning `(U, error)` are rejected with `E_WORKER_SIGNATURE`; only `(Event<U>, error)` is accepted.
    workaround: |
      - Add a shim worker with the enforced signature that calls the docx-style worker, then wraps `U` into `Event<U>`
        before returning. This preserves current compiler checks while the signature policy is aligned with the docx.
    tests: []
  - id: B-2025-10-04-pipeline-parens-optional
    title: Pipeline declaration parentheses are optional per docx; parser incorrectly requires them
    summary: |
      The authoritative docx allows `pipeline <Name> { ... }` (no empty parameter list) and also
      `pipeline <Name>() { ... }`. The current parser rejects the no-parens form with
      E_PARSE_SYNTAX "expected '(', got '{'". This makes the pipeline attribute list effectively
      mandatory syntactically, contrary to the spec which says the attribute list is optional.
    status: ready
    repro:
      - step: cd examples/correct
      - step: ami build
      - observe:
          - code: E_PARSE_SYNTAX
          - message: "expected '(', got '{'" at the pipeline declaration line
          - file: examples/correct/src/main.ami
    config:
      workspace: examples/correct/ami.workspace
      toolchain:
        command: ami build
        mode: default
      references:
        - docx: docs/Asynchronous Machine Interface.docx (pipeline declaration allows optional parens)
        - parser: src/ami/compiler/parser/Parser.parsePipelineDecl.go (requires LParenSym)
    expected_behavior: |
      - Accept both `pipeline Name { ... }` and `pipeline Name() { ... }`. When parentheses are omitted,
        treat the parameter list as empty.
    actual_behavior: |
      - Parser emits E_PARSE_SYNTAX and refuses `pipeline Name { ... }` due to a hard requirement for '('.
    workaround: |
      - Add `()` after the pipeline name to satisfy the current parser until it accepts the optional form.
    tests: []
